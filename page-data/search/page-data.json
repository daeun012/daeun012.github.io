{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\r\n- 버블 정렬(Bubble Sort)이란?\r\n- 버블 정렬 살펴보기\r\n- 버블 정렬 실행해보기 with 자바스크립트\r\n\r\n---\r\n\r\n## 버블 정렬(Bubble Sort)이란?\r\n\r\n서로 인접한 두 원소를 검사해 정렬하는 알고리즘이다.\r\n\r\n- 오름차순을 기준으로 정렬한다.\r\n- 큰 숫자가 왼쪽에서 오른쪽을 향해 거품처럼 이동하는 모습\r\n\r\n## 버블 정렬 살펴보기\r\n\r\n- 이웃한 데이터의 값을 비교해 값의 크기가 다르면 위치를 바꾼다\r\n- 오름차순으로 정렬할 경우 왼쪽 데이터의 크기가 오른쪽 데이터의 크기보다 크면 위치를 바꾼다.\r\n\r\n![실행 화면](./bubbleSortEx.png)\r\n\r\n### 계산량 확인해보기\r\n\r\n데이터의 총 개수를 n이라고 하면 버블 정렬의 비교 횟수는\r\n처음에 n-1 번, 그 다음은 n-2, n-3 번 ... 이다.\r\n\r\n반복 횟수는 (n-1) + (n-2) + (n-3) + ... + 1 이므로 (n²-n)/2이다.  \r\n즉 버블 정렬의 오더는 O(n²)이 된다.\r\n\r\n## 버블 정렬 실행해보기 with 자바스크립트\r\n\r\n```html\r\n<!-- html -->\r\n<form name=\"inputForm\">\r\n  <div>버블 정렬</div>\r\n  <div>\r\n    <input name=\"str\" size=\"50\" type=\"text\" />\r\n    <input type=\"button\" value=\"정렬하기\" onClick=\"doSort()\" />\r\n  </div>\r\n</form>\r\n<form name=\"outputForm\">\r\n  <div>정렬 결과</div>\r\n  <div><textarea name=\"result\" cols=\"50\" rows=\"20\"></textarea></div>\r\n</form>\r\n```\r\n\r\n```javascript\r\n// javascript\r\nfunction doSort() {\r\n  let inputForm = document.forms.inputForm;\r\n  let outputForm = document.forms.outputForm;\r\n  let ary = inputForm.str.value.split(',');\r\n  ary = ary.map((e) => Number(e));\r\n  outputForm.result.value = ary.join(' ') + '\\n';\r\n  outputForm.result.value = outputForm.result.value + '----' + '\\n';\r\n  bubbleSort(ary);\r\n  outputForm.result.value = outputForm.result.value + '----' + '\\n';\r\n  printAry(ary);\r\n  outputForm.result.value = outputForm.result.value + 'done!' + '\\n';\r\n\r\n  function bubbleSort(ary) {\r\n    let i = 0;\r\n    while (i < ary.length - 1) {\r\n      let j = 0;\r\n      while (j < ary.length - i - 1) {\r\n        if (ary[j] > ary[j + 1]) {\r\n          let n = ary[j];\r\n          ary[j] = ary[j + 1];\r\n          ary[j + 1] = n;\r\n        }\r\n        j++;\r\n        printAry(ary);\r\n      }\r\n      i++;\r\n    }\r\n  }\r\n\r\n  function printAry(ary) {\r\n    outputForm.result.value = outputForm.result.value + ary.join(' ') + '\\n';\r\n  }\r\n}\r\n```\r\n\r\n### 실행 화면\r\n\r\n![실행 화면](./bubbleSort.png)\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- [모두의 알고리즘 with 자바스크립트](https://www.gilbut.co.kr/book/view?bookcode=BN002328)\r\n","excerpt":"버블 정렬(Bubble Sort)이란? 버블 정렬 살펴보기 버블 정렬 실행해보기 with 자바스크립트 버블 정렬(Bubble Sort)이란? 서로 인접한 두 원소를 검사해 정렬하는 알고리즘이다. 오름차순을 기준으로 정렬한다. 큰 숫자가 왼쪽에서 오른…","fields":{"slug":"/bubble-sort.md/"},"frontmatter":{"date":"Jul 12, 2021","title":"버블 정렬","tags":["Argorithm","JavaScript"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n- 퀵 정렬(Quick Sort)이란?\r\n- 퀵 정렬 살펴보기\r\n- 퀵 정렬 실행해보기 with 자바스크립트\r\n\r\n---\r\n\r\n## 퀵 정렬(Quick Sort)이란?\r\n\r\n데이터의 범위를 반으로 나눈 다음, 그 범위를 다시 반으로 나누어 정렬하는 처리를 반복한다.\r\n\r\n## 퀵 정렬 살펴보기\r\n\r\n- 우선 피봇(기준 값)을 정한다. 피봇으로 정할 데이터는 어떤 데이터든 상관없다.\r\n- 정렬한 데이터의 크기가 피봇보다 큰 그룹과 작은 그룹으로 분할한다.\r\n- 나눈 그룹 안에서도 똑같이 피붓을 정한 후 위와 같은 방식으로 분할한다.\r\n- 이처럼 분할을 반복해 정렬하는 알고리즘을 `분할 정복 알고리즘`이라고 한다\r\n\r\n![실행 화면](./quickSortEx.png)\r\n\r\n### 계산량 확인해보기\r\n\r\n퀵 정렬은 피봇을 기준으로 한 데이터의 크기에 따라 전체 데이터를 균형 있게 절반씩 분할해 나가며,  \r\n그 결과로 log₂n단 만들어진다.  \r\n오더는 O(nlogn)이다.  \r\n하지만 데이터를 나열한 순서가 좋지 않으면 효율이 나빠지고, 최악의 경우에는 오더가 O(n²)이 될 수 있다.\r\n\r\n## 퀵 정렬 실행해보기 with 자바스크립트\r\n\r\n```html\r\n<!-- html -->\r\n<form name=\"inputForm\">\r\n  <div>퀵 정렬</div>\r\n  <div>\r\n    <input name=\"str\" size=\"50\" type=\"text\" />\r\n    <input type=\"button\" value=\"정렬하기\" onClick=\"doSort()\" />\r\n  </div>\r\n</form>\r\n<form name=\"outputForm\">\r\n  <div>정렬 결과</div>\r\n  <div><textarea name=\"result\" cols=\"50\" rows=\"20\"></textarea></div>\r\n</form>\r\n```\r\n\r\n```javascript\r\n// javascript\r\nfunction doSort() {\r\n  let inputForm = document.forms.inputForm;\r\n  let outputForm = document.forms.outputForm;\r\n  let ary = inputForm.str.value.split(',');\r\n  ary = ary.map(function (e) {\r\n    return Number(e);\r\n  });\r\n  outputForm.result.value = ary.join(' ') + '\\n';\r\n  outputForm.result.value = outputForm.result.value + '---' + '\\n';\r\n  quickSort(ary);\r\n  outputForm.result.value = outputForm.result.value + '---' + '\\n';\r\n  printAry(ary);\r\n  outputForm.result.value = outputForm.result.value + 'done!' + '\\n';\r\n\r\n  function quickSort(ary) {\r\n    function sort(start, end) {\r\n      if (start >= end) {\r\n        return;\r\n      }\r\n      let left = start;\r\n      let right = end;\r\n      let ref = ary[Math.round((left + right) / 2)];\r\n      while (left < right) {\r\n        if (ary[left] >= ref) {\r\n          while (right > left) {\r\n            if (ary[right] <= ref) {\r\n              let n = ary[left];\r\n              ary[left] = ary[right];\r\n              ary[right] = n;\r\n              right = right - 1;\r\n              break;\r\n            }\r\n            right = right - 1;\r\n          }\r\n          printAry(ary);\r\n        }\r\n        left = left + 1;\r\n      }\r\n      if (ary[right] > ref) {\r\n        sort(start, right - 1);\r\n        sort(right, end);\r\n      } else if (ary[right] < ref) {\r\n        sort(start, right);\r\n        sort(right + 1, end);\r\n      } else {\r\n        sort(start, right - 1);\r\n        sort(right + 1, end);\r\n      }\r\n    }\r\n    sort(0, ary.length - 1);\r\n  }\r\n\r\n  function printAry(ary) {\r\n    outputForm.result.value = outputForm.result.value + ary.join(' ') + '\\n';\r\n  }\r\n}\r\n```\r\n\r\n### 실행 화면\r\n\r\n![실행 화면](./quickSort.png)\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- [모두의 알고리즘 with 자바스크립트](https://www.gilbut.co.kr/book/view?bookcode=BN002328)\r\n","excerpt":"퀵 정렬(Quick Sort)이란? 퀵 정렬 살펴보기 퀵 정렬 실행해보기 with 자바스크립트 퀵 정렬(Quick Sort)이란? 데이터의 범위를 반으로 나눈 다음, 그 범위를 다시 반으로 나누어 정렬하는 처리를 반복한다. 퀵 정렬 살펴보기 우선 피…","fields":{"slug":"/quick-sort.md/"},"frontmatter":{"date":"Jul 12, 2021","title":"퀵 정렬(Quick Sort)","tags":["JavaScript","Argorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n- 선택 정렬(Selection Sort)이란?\r\n- 선택 정렬 살펴보기\r\n- 선택 정렬 실행해보기 with 자바스크립트\r\n\r\n---\r\n\r\n## 선택 정렬(Selection Sort)이란?\r\n\r\n값이 가장 작은 숫자를 찾아 가장 왼쪽에 있는 데이터부터 순서대로 데이터를 교환하여 정렬하는 처리를 반복한다.\r\n\r\n## 선택 정렬 살펴보기\r\n\r\n- 우선 정렬하고자 하는 데이터 안에서 값을 하나 골라 임시 최솟값으로 정한다.\r\n- 데이터 전부를 임시 최솟값과 비교한다.\r\n- 임시 최솟값보다 값이 작은 데이터가 있다면, 값이 가장 작은 데이터의 위치와 임시 최솟값의 위치를 바꾼다.\r\n\r\n![실행 화면](./selectionSortEx.png)\r\n\r\n### 계산량 확인해보기\r\n\r\n데이터의 총 개수를 n이라고 하면 선택 정렬의 비교 횟수는\r\n처음에 n-1 번, 그 다음은 n-2, n-3 번 ... 이다.\r\n\r\n반복 횟수는 (n-1) + (n-2) + (n-3) + ... + 1 이므로 (n²-n)/2이다.  \r\n즉 선택 정렬의 오더는 O(n²)이 된다.\r\n\r\n오더가 버블 정렬과 같지만,  \r\n버블 정렬은 데이터의 위치를 바꾸는 횟수가 선택 정렬보다 많기 때문에 선택 정렬이 더 빨리 끝난다. 메모리에 저장된 데이터를 비교하는 처리보다 위치를 바꾸는 처리가 시간이 많이 걸리기 때문이다.\r\n\r\n## 선택 정렬 실행해보기 with 자바스크립트\r\n\r\n```html\r\n<!-- html -->\r\n<form name=\"inputForm\">\r\n  <div>선택 정렬</div>\r\n  <div>\r\n    <input name=\"str\" size=\"50\" type=\"text\" />\r\n    <input type=\"button\" value=\"정렬하기\" onClick=\"doSort()\" />\r\n  </div>\r\n</form>\r\n<form name=\"outputForm\">\r\n  <div>정렬 결과</div>\r\n  <div><textarea name=\"result\" cols=\"50\" rows=\"20\"></textarea></div>\r\n</form>\r\n```\r\n\r\n```javascript\r\n// javascript\r\nfunction doSort() {\r\n  let inputForm = document.forms.inputForm;\r\n  let outputFrom = document.forms.outputForm;\r\n  let ary = inputForm.str.value.split(',');\r\n  ary = ary.map(function (e) {\r\n    return Number(e);\r\n  });\r\n  outputForm.result.value = ary.join(' ') + '\\n';\r\n  outputForm.result.value = outputForm.result.value + '---' + '\\n';\r\n  selectionSort(ary);\r\n  outputForm.result.value = outputForm.result.value + '---' + '\\n';\r\n  printAry(ary);\r\n  outputForm.result.value = outputForm.result.value + 'done!' + '\\n';\r\n\r\n  function selectionSort(ary) {\r\n    let i = 0;\r\n    let min;\r\n    while (i < ary.length) {\r\n      min = i;\r\n      let j = i + 1;\r\n      while (j < ary.length) {\r\n        if (ary[min] > ary[j]) {\r\n          min = j;\r\n        }\r\n        j = j + 1;\r\n        printAry(ary);\r\n      }\r\n      let n = ary[i];\r\n      ary[i] = ary[min];\r\n      ary[min] = n;\r\n      i = i + 1;\r\n    }\r\n  }\r\n\r\n  function printAry(ary) {\r\n    outputForm.result.value = outputForm.result.value + ary.join(' ') + '\\n';\r\n  }\r\n}\r\n```\r\n\r\n### 실행 화면\r\n\r\n![실행 화면](./selectionSort.png)\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- [모두의 알고리즘 with 자바스크립트](https://www.gilbut.co.kr/book/view?bookcode=BN002328)\r\n","excerpt":"선택 정렬(Selection Sort)이란? 선택 정렬 살펴보기 선택 정렬 실행해보기 with 자바스크립트 선택 정렬(Selection Sort)이란? 값이 가장 작은 숫자를 찾아 가장 왼쪽에 있는 데이터부터 순서대로 데이터를 교환하여 정렬하는 처리…","fields":{"slug":"/selection-sort.md/"},"frontmatter":{"date":"Jul 12, 2021","title":"선택 정렬(Selection Sort)","tags":["Argorithm","JavaScript"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n- 시간 복잡성이란?\r\n- O 표기법\r\n\r\n---\r\n\r\n## 시간 복잡성이란?\r\n\r\n계산의 복잡성,\r\n계산이 복잡해지는 만큼 처리하는 스텝의 개수가 늘어나므로 `실행 시간이 오래 걸린다`는 뜻이다.\r\n\r\n- 스텝 : CPU가 실행하는 명령\r\n\r\n---\r\n\r\n## O 표기법\r\n\r\n알고리즘의 `계산량이 얼마나` 될지 대략적으로 표현한 지표.  \r\n구체적인 실행 시간이나 명령의 개수는 알려주지 않는다.\r\n\r\n같은 프로그램을 실행해도 `컴퓨터의 처리 성능`에 따라 `실행 시간이 달라`지기 때문에,\r\n입력된 데이터 n의 크기에 따라 시간 계산량이 `어느 정도의 비율로 늘어나는지`를 O(n 식)의 형태로 표현하는 것이다.\r\n\r\nO(n) : 입력한 데이터의 크기(개수나 자릿수 등)을 n이라고 했을 때 알고리즘을 최대 n번 실행하면 처리가 완료된다는 뜻이다.(반드시 n번만에 완료된다는 것이 아니라 알고리즘의 최대 실행 횟수가 n번이라는 뜻이다.)\r\n\r\n### O 표기법의 식\r\n\r\n차수가 가장 큰 항만 남기고 계수는 1로 한다.\r\n\r\n```\r\nO(3) → O(1)\r\nO(n-1) → O(n)\r\nO(4n²+3n) → O(n²)\r\nO(n³+7n²+12) → O(n³)\r\nO(2n³+3m²) → O(n³+m²)\r\n```\r\n\r\n### 괄호 안에 자주 사용되는 식과 계산량의 대소 관계\r\n\r\n![O 표기법](./priority.png)\r\n\r\n### 오더 수와 시간 계산량\r\n\r\n시간 계산량의 오더에서  \r\nO(n), O(n²), O(n³)과 같은 오더를 가르켜 `다항 시간 알고리즘`이라 부르며  \r\nO(n!), O(2ⁿ)과 같은 오더는 `지수 시간 알고리즘`이라 부른다.\r\n\r\n다항 시간 알고리즘으로는 어느 정도 실용적인 프로그램을 만들어 낼 수 있다.  \r\n하지만 지수 시간 알고리즘은 n값이 증가함에 따라 계산량도 급격히 늘어나기 때문에 현실적인 시간 내에 문제를 해결하지 못할 우려가 있다.\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- [모두의 알고리즘 with 자바스크립트](https://www.gilbut.co.kr/book/view?bookcode=BN002328)\r\n","excerpt":"시간 복잡성이란? O 표기법 시간 복잡성이란? 계산의 복잡성,\n계산이 복잡해지는 만큼 처리하는 스텝의 개수가 늘어나므로 는 뜻이다. 스텝 : CPU가 실행하는 명령 O 표기법 알고리즘의  될지 대략적으로 표현한 지표. 구체적인 실행 시간이나 명령의 …","fields":{"slug":"/time-complexity/"},"frontmatter":{"date":"Jul 12, 2021","title":"시간 복잡성과 O 표기법","tags":["Argorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n### 1. mongoose 설치\r\n\r\n```bash\r\n$ npm install mongoose\r\n```\r\n\r\n### 2. MongoDB 연결 파일 생성\r\n\r\n현재 폴더 구조입니다.\r\n\r\n![현재 폴더 구조](./mongoose.png)\r\n\r\n```javascript\r\n// server/config/mongoose.js\r\nconst mongoose = require('mongoose');\r\nmodule.exports = () => {\r\n  function connect() {\r\n    mongoose.connect('localhost:27017', function (err) {\r\n      if (err) {\r\n        console.error('mongodb connection error', err);\r\n      }\r\n      console.log('mongodb connected');\r\n    });\r\n  }\r\n  connect();\r\n  mongoose.connection.on('disconnected', connect);\r\n};\r\n```\r\n\r\n로컬 몽고디비 주소인 localhost:27017을 사용했다.\r\n만약 몽고 디비 아이디와 비밀번혹 있다면,\r\n아이디:비밀번호@localhost:27017을 사용하면 된다.\r\n\r\n```javascript\r\nmongoose.connect('아이디:비밀번호@주소:포트/admin', { dbName: '데이터베이스' }, function (err) {});\r\n```\r\n\r\n### 3. 서버 실행시 자동으로 MongoDB 연결하기\r\n\r\n```javascript\r\n// server/main.js\r\nconst express = require('express');\r\nconst path = require('path');\r\nconst morgan = require('morgan');\r\nconst mongoose = require('./confing/mongoose.js'); //(*)\r\nconst session = require('express-session');\r\nimport api from './routes';\r\n\r\nconst webpack = require('webpack');\r\nconst WebpackDevServer = require('webpack-dev-server');\r\n\r\nlet app = express();\r\n\r\nconst port = 3000;\r\nconst devPort = 9000;\r\n\r\n// mongodb 연결\r\nmongoose();\r\n\r\n....\r\n```\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- https://www.zerocho.com/category/NodeJS/post/57924d1e8241b6f43951af1a\r\n","excerpt":"1. mongoose 설치 2. MongoDB 연결 파일 생성 현재 폴더 구조입니다.  로컬 몽고디비 주소인 localhost:27017을 사용했다.\n만약 몽고 디비 아이디와 비밀번혹 있다면,\n아이디:비밀번호@localhost:27017을 사용하면 …","fields":{"slug":"/mongodb-connect.md/"},"frontmatter":{"date":"Aug 15, 2020","title":"mongoose로 MongoDB 연결하기","tags":["Node.js","MongoDB"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\nnpm에서 dependency를 최신 버전으로 업데이트 하려면 하나씩 따로 업데이트해줘야 하는데.\n그냥 한번에 업데이트 하는 방법은 없을까?\n\n## npm-check-updates 를 이용한 업데이트\n\n### 1. npm-check-updates 전역 설치\n\n```bash\n$ npm install -g npm-check-updates\n\n```\n\n### 2. npm-check-updates 실행하기\n\n```bash\n$ ncu -u\n\n// 완료 되었으면 아래 명령어를 실행한다.\n\n$ npm install\n```\n\n### 3. 그러나 주의하자\n\n모든 의존성을 한번에 업데이트 하는 것은 프로젝트 관점에서 굉장히 큰 리스크를 가지고 있는 작업이다.\n하지만 여러가지 보일러플레이트를 github에서 관리해야할 때에는 분명 일괄 업데이트 기능도 필요하기 마련이다.\n강제로 최신버전으로 업데이트된 의존성들 사이의 호환성은 보장되지 않기 때문에 주의해서 사용하자\n\n---\n\n#### Reference\n\nhttps://ahribori.com/article/5a7996097eaff3172844ddb9\n","excerpt":"npm에서 dependency를 최신 버전으로 업데이트 하려면 하나씩 따로 업데이트해줘야 하는데.\n그냥 한번에 업데이트 하는 방법은 없을까? npm-check-updates 를 이용한 업데이트 1. npm-check-updates 전역 설치 2. n…","fields":{"slug":"/npm-check-updates/"},"frontmatter":{"date":"Aug 13, 2020","title":"pakage.json 종속성을 최신 버전으로 업데이트하기","tags":["npm","Node.js"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n- bundler란?\r\n- Webpack이란?\r\n- Babel과 Webpack 함께 사용하기\r\n\r\n---\r\n\r\n## bundler란?\r\n\r\n웹 사이트를 만들다보면 js, css, img 등 수 많은 파일들이 생겨난다. 웹 사이트 로딩 시 많은 파일들이 다운되어지고, 서버와의 접속이 많아져 애플리케이션의 로딩이 느려진다.\r\n\r\n각각의 서로 다른 패키지들이 서로 같은 이름을 가진 변수, 함수를 사용할 수 있다.\r\n이는 예상치 못한 충돌을 발생시킨다.\r\n\r\n이를 해결하기 위해 등장한 도구들을 `bundler`라 한다.\r\n\r\nbundle? '묶는다' 라는 뜻이다.\r\n\r\n### 대표적인 bundler\r\n\r\n- webpack\r\n- broserify\r\n- parcel\r\n\r\n---\r\n\r\n## Webpack이란?\r\n\r\n의존 관계에 있는 모듈들을 하나의 자바스크립트로 번들링하는 모듈 번들러\r\n\r\n- 이를 사용하면 의존 모듈이 하나의 파일로 번들링되므로 별도의 모듈 로더가 필요 없다.\r\n- 다수의 자바스크립트 파일을 하나의 파일로 번들링하므로 html 파일에서 script 태그로 다수의 자바스크립트 파일을 로드해야 하는 번거로움도 사라진다.\r\n\r\n### Webpack 설치\r\n\r\n```bash\r\n# Webpack V4는 webpack-cli를 요구한다\r\n$ npm install --save-dev webpack webpack-cli\r\n```\r\n\r\n---\r\n\r\n## Babel과 Webpack 함께 사용하기\r\n\r\n```bash\r\n# babel-loader 설치\r\n$ npm install --save-dev babel-loader\r\n```\r\n\r\n### webpack.config.js 파일 작성하기\r\n\r\n`webpack.config.js`은 Webpack이 실행될 때 참조하는 설정 파일이다.  \r\n프로젝트 루트에 `webpack.config.js` 파일을 생성하고 아래와 같이 작성한다.\r\n\r\n```javascript\r\n// Webpack이 실행될 때 참조하는 설정 파일\r\nconst path = require('path');\r\n\r\nmodule.exports = {\r\n  // entry file\r\n  entry: './src/js/main.js',\r\n\r\n  // 컴파일 + 번들링된 js 파일이 저장될 경로와 이름 지정\r\n  output: {\r\n    path: path.resolve(__dirname, 'dist/js'),\r\n    filename: 'bundle.js',\r\n  },\r\n\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.js$/,\r\n        include: [path.resolve(__dirname, 'src/js')],\r\n        exclude: /node_modules/,\r\n        use: {\r\n          loader: 'babel-loader',\r\n          options: {\r\n            presets: ['@babel/preset-env'],\r\n          },\r\n        },\r\n      },\r\n    ],\r\n  },\r\n};\r\n```\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- https://poiemaweb.com/es6-babel-webpack-2\r\n","excerpt":"bundler란? Webpack이란? Babel과 Webpack 함께 사용하기 bundler란? 웹 사이트를 만들다보면 js, css, img 등 수 많은 파일들이 생겨난다. 웹 사이트 로딩 시 많은 파일들이 다운되어지고, 서버와의 접속이 많아져 애…","fields":{"slug":"/webpack/"},"frontmatter":{"date":"Aug 11, 2020","title":"Webpack","tags":["JavaScript","ES6"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n- Babel이란?\r\n- Babel 사용해보기\r\n\r\n---\r\n\r\n## Babel이란?\r\n\r\n**Babel은 JavaScript 컴파일러이다.**\r\n즉, 최신 사양의 자바스크립트 코드를 IE나 구형 브라우저에서도 동작하는 ES5 이하의 코드로 변환하는 트랜스파일러라고 보면 된다.\r\n\r\n```javascript\r\n// ES6 화살표 함수와 ES7 지수 연산자\r\n[1, 2, 3].map((n) => n ** n);\r\n```\r\n\r\nBabel은 위와 같은 코드를 아래와 같이 변환한다.\r\n\r\n```javascript\r\n// ES5\r\n('use strict');\r\n\r\n[1, 2, 3].map(function (n) {\r\n  return Math.pow(n, n);\r\n});\r\n```\r\n\r\n---\r\n\r\n## Babel 사용해보기\r\n\r\n### 1. 사용하기 전 준비\r\n\r\n```bash\r\n$ npm install --save-dev @babel/core @babel/cli @babel/preset-env\r\n```\r\n\r\n설치가 완료되었으면 프로젝트 루트에 `.babelrc` 파일을 생성하고 아래와 같이 작성한다.\r\n\r\n```json\r\n// 지금 설치한 @babel/preset-env를 사용하겠다는 의미이다.\r\n{\r\n  \"presets\": [\"@babel/preset-env\"]\r\n}\r\n```\r\n\r\n### 2. @babel/preset-env는 뭐지?\r\n\r\n`@babel/preset-env`는 필요한 플러그인들을 프로젝트 지원 환경에 맞춰서 동적으로 결정해준다.  \r\n즉, 함께 사용되어야하는 Babel 플러그인을 모아 둔 것이다.  \r\n이를 **Babel 프리셋**이라고 부르며, Babel이 제공하는 공식 Babel 프리셋은 아래와 같다.\r\n\r\n- @babel/preset-env\r\n- @babel/preset-flow\r\n- @babel/preset-react\r\n- @babel/preset-typescript\r\n\r\n### 3. npm script를 사용해 트랜스파일링 하기\r\n\r\n```json\r\n// package.json 파일에 build를 추가한다.\r\n{\r\n  \"name\": \"es6-project\",\r\n  \"version\": \"1.0.0\",\r\n  \"scripts\": {\r\n    \"build\": \"babel src/js -w -d dist/js\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@babel/cli\": \"^7.7.0\",\r\n    \"@babel/core\": \"^7.7.2\",\r\n    \"@babel/preset-env\": \"^7.7.1\"\r\n  }\r\n}\r\n```\r\n\r\n- `-w` : 타킷 폴더에 있는 모든 파일들의 변경을 감지해 자동으로 트랜스파일한다.(`--watch` 옵션의 축약형)\r\n- `-d` : 트랜스파일링 된 결과물이 저장될 폴더를 지정한다(`--out-dir` 옵션의 축약형)\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- https://poiemaweb.com/es6-babel-webpack-1\r\n","excerpt":"Babel이란? Babel 사용해보기 Babel이란? Babel은 JavaScript 컴파일러이다.\n즉, 최신 사양의 자바스크립트 코드를 IE나 구형 브라우저에서도 동작하는 ES5 이하의 코드로 변환하는 트랜스파일러라고 보면 된다. Babel은 위와…","fields":{"slug":"/babel/"},"frontmatter":{"date":"Aug 10, 2020","title":"Babel","tags":["JavaScript","ES6"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n### 상속(Inheritance)\r\n\r\n<img src=\"./inheritance1.png\" title=\"inheritance\" alt=\"inheritance\" />\r\n\r\n- 자식 클래스는 어머니클래스를 extends 함으로써 메소드를 상속 받을 수 있다\r\n\r\n<img src=\"./inheritance2.png\" title=\"inheritance\" alt=\"inheritance\" />\r\n\r\n- interface :　메소드만 선언\r\n- implements : 메소드를 정의해야만 함\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- https://opentutorials.org/course/4408\r\n","excerpt":"상속(Inheritance) 자식 클래스는 어머니클래스를 extends 함으로써 메소드를 상속 받을 수 있다 interface :　메소드만 선언 implements : 메소드를 정의해야만 함 Reference https://opentutorials.…","fields":{"slug":"/java-inheritance.md/"},"frontmatter":{"date":"Feb 05, 2020","title":"Java의 상속(Inheritance)","tags":["Java"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n## Object.assign() 사용하기\r\n\r\n열거할 수 있는 하나 이상의 복사하고자 하는 객체로부터 대상 객체로 속성을 복사할 때 사용한다. 대상 객체를 반환한다.\r\n\r\n```javascript\r\nObject.assign(dest, [src1, src2, src3...])\r\n```\r\n\r\n- dest : 대상 객체(목표로 하는 객체)\r\n- src1, ...., srcN : 복사하고자 하는 객체\r\n\r\n```javascript\r\nlet user = { name: 'John' };\r\n\r\nlet permissions1 = { canView: true };\r\nlet permissions2 = { canEdit: true };\r\n\r\n// permissions1과 permissions2의 프로퍼티를 user로 복사한다.\r\nObject.assign(user, permissions1, permissions2);\r\n\r\n// now user = { name: \"John\", canView: true, canEdit: true }\r\n```\r\n\r\n목표 객체(user)에 동일한 이름을 가진 프로퍼티가 있는 경우\r\n\r\n```javascript\r\nlet user = { name: 'John' };\r\n\r\nObject.assign(user, { name: 'Pete' });\r\n\r\nalert(user.name); // user = { name: \"Pete\" }\r\n```\r\n\r\n빈 배열에 복사하기\r\n\r\n```javascript\r\nlet user = {\r\n  name: 'John',\r\n  age: 30,\r\n};\r\n\r\nlet clone = Object.assign({}, user);\r\n```\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- https://ko.javascript.info/object-copy\r\n- https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\r\n","excerpt":"Object.assign() 사용하기 열거할 수 있는 하나 이상의 복사하고자 하는 객체로부터 대상 객체로 속성을 복사할 때 사용한다. 대상 객체를 반환한다. dest : 대상 객체(목표로 하는 객체) src1, ...., srcN : 복사하고자 하는…","fields":{"slug":"/js-object-assign/"},"frontmatter":{"date":"Oct 18, 2019","title":"Object.assign을 이용한 객체 복사하기","tags":["JavaScript","ES6"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n- 'in' 연산자 사용하기\n- 'in' 연산자 응용하기 : 'for...in' 반복문\n\n---\n\n## 'in' 연산자 사용하기\n\n```javascript\n'key' in object;\n```\n\n※ in 왼쪽엔 반드시 프로퍼티 이름이 와야한다.\n\n```javascript\nlet user = { name: 'John', age: 30 };\n\nalert('age' in user); // user.age가 존재하므로 true 출력\nalert('blabla' in user); // user.blabla 존재하지 않으므로 false 출력\n\nlet obj = {\n  test: undefined,\n};\n\nalert(obj.test); // 값이 `undefined`이므로, 얼럿 창엔 undefined가 출력\n\nalert('test' in obj); // `in`을 사용하면 프로퍼티 유무를 제대로 확인할 수 있다.(true가 출력됨).\n```\n\n---\n\n## 'in' 연산자 응용하기 : 'for...in' 반복문\n\n```javascript\nfor (key in object) {\n  // 각 프로퍼티 키(key)를 이용하여 본문(body)을 실행한다.\n}\n```\n\n```javascript\nlet user = {\n  name: 'John',\n  age: 30,\n  isAdmin: true,\n};\n\nfor (let key in user) {\n  // 키\n  alert(key); // name, age, isAdmin\n  // 키에 해당하는 값\n  alert(user[key]); // John, 30, true\n}\n```\n\n---\n\n#### Reference\n\n- https://ko.javascript.info/object\n","excerpt":"'in' 연산자 사용하기 'in' 연산자 응용하기 : 'for...in' 반복문 'in' 연산자 사용하기 ※ in 왼쪽엔 반드시 프로퍼티 이름이 와야한다. 'in' 연산자 응용하기 : 'for...in' 반복문 Reference https://ko.…","fields":{"slug":"/js-object-in/"},"frontmatter":{"date":"Oct 16, 2019","title":"in 연산자로 객채의 프로퍼티 존재 여부 확인하기","tags":["JavaScript","ES6"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n- npm install --save-prod? npm install --save-dev?\r\n- npm install 와 npm install -g의 차이\r\n\r\n---\r\n\r\n## npm install --save-prod? npm install --save-dev?\r\n\r\n### 1. -P, --save-prod 플래그 사용\r\n\r\n- 패키지를 설치하고 프로젝트의 `dependencies` 목록에 추가한다.\r\n- 하지만 npm5부터는 이 플래그를 사용하지 않아도 dependecies에 항목을 추가할 수 있다.\r\n\r\n### 2. -D, —save-dev 플래그 사용\r\n\r\n- 패키지를 설치하고 프로젝트의 `devDependencies` 목록에 추가한다.\r\n\r\n### 3. dependencies 와 devDependencies\r\n\r\n- `dependencies` : express 패키지 처럼 실제 코드도 포함되며 앱 구동을 위해 필요한 의존성 파일들\r\n- `devDependencies` : concurrently 패키지처럼 실제 코드에 포함되지 않으며 개발 단계에만 필요한 의존성 파일들\r\n\r\n### 4. 굳이 사용하는 이유가 뭘까?\r\n\r\n플래그를 사용해 dependencies 와 devDependencies 로 의존성 목록을 구분하면 “이건 개발용, 이건 실제 서비스용” 으로 구분하기 쉬워진다는 면에서 개발자들에게 필요한 기능이라고 볼 수 있다.\r\n\r\n---\r\n\r\n## npm install 와 npm install -g 의 차이\r\n\r\n- `npm install (패키지명)` : 프로젝트 폴더에 패키지 설치\r\n- `npm install -g (패키지명)` : 시스템 폴더에 패키지 설치\r\n  (win10 기준으로는 `(사용자명)\\AppData\\Roaming\\npm\\node_modules` )\r\n  시스템의 node_modules 폴더 경로는 `npm root -g` 를 통해 찾을 수 있다.\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- https://ko.javascript.info/\r\n","excerpt":"npm install --save-prod? npm install --save-dev? npm install 와 npm install -g의 차이 npm install --save-prod? npm install --save-dev? 1. -P, -…","fields":{"slug":"/npm/"},"frontmatter":{"date":"Jun 05, 2019","title":"npm","tags":["Node.js","npm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n## PropTypes\r\n\r\n컴포넌트에 전달된 props를 검사합니다.\r\n\r\n### 1. prop-types 라이브러리 설치\r\n\r\n`React.PropTypes`는 원래 React 패키지에 내장 되어 있었습니다.  \r\n현재는 다른 패키지로 이동하여 따로 `prop-types` 라이브러리를 설치 해줘야 합니다.\r\n\r\n```bash\r\n$ npm install prop-types\r\n```\r\n\r\n`pakage.json` 파일로 들어가 다운되었는지 확인합니다.  \r\ndependencies 에 `prop-types`가 있다면 설치가 완료된 것입니다.\r\n\r\n```json\r\n.....\r\n\"dependencies\": {\r\n    \"@testing-library/jest-dom\": \"^4.2.4\",\r\n    \"@testing-library/react\": \"^9.5.0\",\r\n    \"@testing-library/user-event\": \"^7.2.1\",\r\n    \"axios\": \"^0.19.2\",\r\n    \"gh-pages\": \"^2.2.0\",\r\n    \"prop-types\": \"^15.7.2\", //(*)\r\n    \"react\": \"^16.13.1\",\r\n    \"react-dom\": \"^16.13.1\",\r\n    \"react-scripts\": \"3.4.1\"\r\n  },\r\n.....\r\n```\r\n\r\n### 2. import 하기\r\n\r\n```javascript\r\nimport PropTypes from 'prop-types';\r\n```\r\n\r\n### 3. 사용하기\r\n\r\n```javascript\r\nimport React from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\nclass Test extends React.Component {\r\n  render() {\r\n    return (\r\n      <div>\r\n        <h1>Hello, {this.props.name}</h1>\r\n        <p>age : {this.props.age}</p>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nTest.propTypes = {\r\n  name: PropTypes.string.isRequired, //name은 문자이고, 부모 컴포넌트로부터 반드시 값을 받아야한다.\r\n  age: PropTypes.number, //age는 숫자\r\n};\r\n\r\nexport default Test;\r\n```\r\n\r\n만약 `name props`에 숫자가 전달되거나 아무런 값도 전달 받지 못했다면, 경고문이 JavaScript 콘솔을 통해 보일 것입니다.\r\n\r\n<img src=\"./error.png\" align=\"left\" width=\"450px\" height=\"250px\"  title=\"error\" alt=\"error\"/>\r\n\r\n### 4. PropTypes 공식 문서\r\n\r\n**[PropTypes 공식 문서](https://ko.reactjs.org/docs/typechecking-with-proptypes.html)**에 따라 다양한 Type을 검사하는 방법을 보면 아래와 같습니다.\r\n\r\n```javascript\r\nimport PropTypes from 'prop-types';\r\n\r\nMyComponent.propTypes = {\r\n  // prop가 특정 JS 형식임을 선언할 수 있습니다.\r\n  // 이것들은 기본적으로 모두 선택 사항입니다.\r\n  optionalArray: PropTypes.array,\r\n  optionalBool: PropTypes.bool,\r\n  optionalFunc: PropTypes.func,\r\n  optionalNumber: PropTypes.number,\r\n  optionalObject: PropTypes.object,\r\n  optionalString: PropTypes.string,\r\n  optionalSymbol: PropTypes.symbol,\r\n\r\n  // 랜더링 될 수 있는 것들은 다음과 같습니다.\r\n  // 숫자(numbers), 문자(strings), 엘리먼트(elements), 또는 이러한 타입들(types)을\r\n  // 포함하고 있는 배열(array) (혹은 배열의 fragment)\r\n  optionalNode: PropTypes.node,\r\n\r\n  // React 엘리먼트.\r\n  optionalElement: PropTypes.element,\r\n\r\n  // React 엘리먼트 타입 (ie. MyComponent)\r\n  optionalElementType: PropTypes.elementType,\r\n\r\n  // prop가 클래스의 인스턴스임을 선언할 수 있습니다.\r\n  // 이 경우 JS's instanceof 연산자를 사용합니다.\r\n  optionalMessage: PropTypes.instanceOf(Message),\r\n\r\n  // 열거형(enum)으로 처리하여 prop가 특정 값들로 제한되도록 할 수 있습니다.\r\n  optionalEnum: PropTypes.oneOf(['News', 'Photos']),\r\n\r\n  // 여러 종류중 하나의 종류가 될 수 있는 객체\r\n  optionalUnion: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.instanceOf(Message)]),\r\n\r\n  // 특정 타입의 행렬\r\n  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),\r\n\r\n  // 특정 타입의 프로퍼티 값들을 갖는 객체\r\n  optionalObjectOf: PropTypes.objectOf(PropTypes.number),\r\n\r\n  // 특정 형태를 갖는 객체\r\n  optionalObjectWithShape: PropTypes.shape({\r\n    color: PropTypes.string,\r\n    fontSize: PropTypes.number,\r\n  }),\r\n\r\n  // An object with warnings on extra properties\r\n  optionalObjectWithStrictShape: PropTypes.exact({\r\n    name: PropTypes.string,\r\n    quantity: PropTypes.number,\r\n  }),\r\n\r\n  // 위에 있는 것 모두 `isRequired`와 연결하여 prop가 제공되지 않았을 때\r\n  // 경고가 보이도록 할 수 있습니다.\r\n  requiredFunc: PropTypes.func.isRequired,\r\n\r\n  // 모든 데이터 타입이 가능한 값\r\n  requiredAny: PropTypes.any.isRequired,\r\n\r\n  // 사용자 정의 유효성 검사기를 지정할 수도 있습니다.\r\n  // 검사 실패 시에는 에러(Error) 객체를 반환해야 합니다.\r\n  // `oneOfType`안에서는 작동하지 않으므로 `console.warn` 혹은 throw 하지 마세요.\r\n  customProp: function (props, propName, componentName) {\r\n    if (!/matchme/.test(props[propName])) {\r\n      return new Error('Invalid prop `' + propName + '` supplied to' + ' `' + componentName + '`. Validation failed.');\r\n    }\r\n  },\r\n\r\n  // `arrayOf` 와 `objectOf 에 사용자 정의 유효성 검사기를 적용할 수 있습니다.\r\n  // 검사 실패 시에는 에러(Error) 객체를 반환해야 합니다.\r\n  // 유효성 검사기는 배열(array) 혹은 객체의 각 키(key)에 대하여 호출될 것입니다.\r\n  // 유효성 검사기의 첫 두 개의 변수는 배열 혹은 객체 자신과 현재 아이템의 키입니다.\r\n\r\n  customArrayProp: PropTypes.arrayOf(function (propValue, key, componentName, location, propFullName) {\r\n    if (!/matchme/.test(propValue[key])) {\r\n      return new Error(\r\n        'Invalid prop `' + propFullName + '` supplied to' + ' `' + componentName + '`. Validation failed.'\r\n      );\r\n    }\r\n  }),\r\n};\r\n```\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- https://velopert.com/1130\r\n- https://ko.reactjs.org/\r\n","excerpt":"PropTypes 컴포넌트에 전달된 props를 검사합니다. 1. prop-types 라이브러리 설치 는 원래 React 패키지에 내장 되어 있었습니다. 현재는 다른 패키지로 이동하여 따로  라이브러리를 설치 해줘야 합니다.  파일로 들어가 다운되었…","fields":{"slug":"/react-proptypes.md/"},"frontmatter":{"date":"Jun 03, 2019","title":"React PropTypes를 사용해 타입 검사하기","tags":["React"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n- async\r\n- await\r\n- async-await : 에러 핸들링하기\r\n- async/await 과 promise.then/catch 비슷한데 뭘 쓰지?\r\n\r\n---\r\n\r\n## async\r\n\r\n`async`는 function 앞에 위치한다.\r\n\r\n```javascript\r\nasync function f() {\r\n  return 1;\r\n}\r\n\r\nf().then(alert); // 1\r\n```\r\n\r\n- function 앞에 `async`를 붙이면 해당 함수는 항상 프라미스를 반환한다.\r\n\r\n---\r\n\r\n## await\r\n\r\n```javascript\r\n// await는 async 함수 안에서만 동작한다.\r\nasync function f() {\r\n  let promise = new Promise((resolve, reject) => {\r\n    setTimeout(() => resolve('완료!'), 1000);\r\n  });\r\n\r\n  let result = await promise; // 프라미스가 이행될 때까지 기다림\r\n\r\n  alert(result); // \"완료!\"\r\n}\r\n\r\nf();\r\n```\r\n\r\n- 프라미스가 처리될 때까지 함수 실행을 기다리게 한다.\r\n- 프라미스가 처리되면 그결과와 함께 실행이 재게 된다.\r\n- 프라미스가 처리되길 기다리는 동안에 엔진은 다른 일(다른 스크립트를 실행, 이벤트 처리 등)을 할 수 있다.\r\n\r\n---\r\n\r\n## async & await : 에러 핸들링하기\r\n\r\n```javascript\r\nasync function f() {\r\n  await Promise.reject(new Error('에러 발생!'));\r\n}\r\n\r\n// throw문을 사용해 위와 동일한 코드를 작성할 수 있다.\r\nasync function f() {\r\n  throw new Error('에러 발생!');\r\n}\r\n\r\n// 또는 try catch문을 사용해 잡을 수 있다.\r\nasync function f() {\r\n  try {\r\n    let response = await fetch('http://유효하지-않은-url');\r\n    let user = await response.json();\r\n  } catch (err) {\r\n    // fetch와 response.json에서 발행한 에러 모두를 여기서 잡습니다.\r\n    alert(err);\r\n  }\r\n}\r\n\r\nf();\r\n```\r\n\r\n---\r\n\r\n## async/await 과 promise.then/catch 비슷한데 뭘 쓰지?\r\n\r\n비슷하다. 둘 중 편한 것을 쓰면 된다.\r\n\r\n하지만 여러 개의 프라미스가 모두 처리되길 기다려야 하는 상황이라면...\r\n\r\n```javascript\r\n// 프라미스 처리 결과가 담긴 배열을 기다립니다.\r\nlet results = await Promise.all([\r\n  fetch(url1),\r\n  fetch(url2),\r\n  ...\r\n]);\r\n```\r\n\r\n실패한 프라미스에서 발생한 에러는 보통 에러와 마찬가지로 Promise.all로 전파된다. 에러 때문에 생긴 예외는 try...catch로 감싸 잡을 수 있다.\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- https://ko.javascript.info/\r\n","excerpt":"async await async-await : 에러 핸들링하기 async/await 과 promise.then/catch 비슷한데 뭘 쓰지? async 는 function 앞에 위치한다. function 앞에 를 붙이면 해당 함수는 항상 프라미스를 …","fields":{"slug":"/async-await/"},"frontmatter":{"date":"Jun 02, 2019","title":"async-await","tags":["JavaScript","ES6"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n- 컴포넌트 초기 생성(Mount)\r\n- 컴포넌트 업데이트\r\n- 컴포넌트 제거(마운트 해제)\r\n\r\n---\r\n\r\n## 컴포넌트 초기 생성(Mount)\r\n\r\n컴포넌트가 브라우저에 나타나기 전, 후에 호출되는 API  \r\n아래의 순서대로 호출 된다.\r\n\r\n- `constructor()`\r\n- `static getDerivedStateFromProps()`\r\n- `render()`\r\n- `componentDidMount()`\r\n\r\n### 1. constructor( )\r\n\r\n컴포넌트 생성자 함수, 컴포넌트가 새로 만들어질 때마다 이 함수가 호출된다.\r\n\r\n### 2. static getDerivedStateFromProps( )\r\n\r\n```javascript\r\nstatic getDerivedStateFromProps(prosp,state) {\r\n  // 여기서는 setState 를 하는 것이 아니라\r\n  // 특정 props 가 바뀔 때 설정하고 설정하고 싶은 state 값을 리턴하는  형태로 사용된다.\r\n  /*\r\n  if (props.value !== state.value) {\r\n    return { value: props.value };\r\n  }\r\n  return null; // null 을 리턴하면 따로 업데이트 할 것은 없다라는 의미\r\n  */\r\n}\r\n```\r\n\r\n최초 마운트 시와 업데이트 시 모두에서 render 메서드를 호출하기 직전에 호출된다.\r\n\r\n- 부모 컴포넌트가 다시 렌더링을 발생 시켰을 때에만 실행된다.\r\n- 해당 컴포넌트 내에서 지역적인 `setState()`가 발생한 경우에는 실행되지 않는다.\r\n\r\n### 3. componentDidMount( )\r\n\r\n컴포넌트가 마운트된 직후, 즉 컴포넌트가 화면에 나타나게 됐을 때 호출된다. 외부에서 데이터를 불러오기 위해, 네트워크 요청을 보내기 적절한 위치이다.\r\n\r\n- 외부 라이브러리 연동 : D3,\r\n- 컴포넌트에서 필요한 데이터 요청 : Ajax, GraphQL, etc\r\n- DOM에 관련된 작업 : 스크롤 설정, 크기 읽어오기 등\r\n\r\n---\r\n\r\n## 컴포넌트 업데이트\r\n\r\nprops 또는 state가 변경되어 컴포넌트가 다시 렌더링될 때, 아래의 순서대로 호출된다.\r\n\r\n- `static getDerivedStateFromProps()`\r\n- `shouldComponentUpdate()`\r\n- `render()`\r\n- `getSnapshotBeforeUpdate()`\r\n- `componentDidUpdate()`\r\n\r\n### 1. shouldComponentUpdate( )\r\n\r\n```javascript\r\nshouldComponentUpdate(nextProps, nextState) {\r\n  // return false 하면 render()를 발생시키지 않는다.\r\n  // return this.props.checked !== nextProps.checked\r\n  return true;\r\n}\r\n```\r\n\r\n이 메서드는 오직 성능 최적화만을 위한 것이다.\r\n\r\n- `this.props`와 `nextProps`, 그리고 `this.state`와 `nextState`를 비교해 사용한다.\r\n\r\n### 2. getSnapshotBeforeUpdate( )\r\n\r\n```javascript\r\ngetSnapshotBeforeUpdate(prevProps, prevState);\r\n```\r\n\r\n가장 마지막으로 렌더링된 결과가 DOM 등에 반영되었을 때에 호출된다. 이 생명주기 메서드가 반환하는 값은 `componentDidUpdate()`에 인자로 전달된다.\r\n\r\n### 3. componentDidUpdate( )\r\n\r\n```javascript\r\ncomponentDidUpdate(prevProps, prevState, snapshot);\r\n```\r\n\r\n이 메서드는 갱신이 일어난 직후에 호출된다.\r\n\r\n- 이전과 현재의 props를 비교해 네트워크 요청을 보내는 작업이 대부분 이 메서드에서 이루어진다.\r\n\r\n```javascript\r\ncomponentDidUpdate(prevProps) {\r\n  // 전형적인 사용 사례 (props 비교)\r\n  if (this.props.userID !== prevProps.userID) {\r\n    this.fetchData(this.props.userID);\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 컴포넌트 제거(마운트 해제)\r\n\r\n- `componentWillUnmount()`\r\n\r\n### 1. componentWillUnmount( )\r\n\r\n```javascript\r\ncomponentWillUnmount() {\r\n  // 이벤트, setTimeout, 외부 라이브러리 인스턴스 제거\r\n}\r\n```\r\n\r\n컴포넌트가 마운트 해제되어 제거되기 직전에 호출된다.\r\n\r\n- `componentDidMount()` 내에서 생성된 구독 해제\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- https://velopert.com/1130\r\n- https://ko.reactjs.org/\r\n","excerpt":"컴포넌트 초기 생성(Mount) 컴포넌트 업데이트 컴포넌트 제거(마운트 해제) 컴포넌트 초기 생성(Mount) 컴포넌트가 브라우저에 나타나기 전, 후에 호출되는 API 아래의 순서대로 호출 된다.     1. constructor( ) 컴포넌트 생성…","fields":{"slug":"/react-lifecycle/"},"frontmatter":{"date":"May 30, 2019","title":"React LifeCycle(리액트 생명주기)","tags":["React"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n- Promise 기본\n- 메서드 : then, catch, finally\n\n---\n\n## Promise 기본\n\n### 1. promise 객체 생성\n\n```javascript\nlet promise = new Promise(function (resolve, reject) {\n  // new Promise에 전달되는 함수 : executor(실행자, 실행함수)\n});\n```\n\n- `resolve(value)` — 일이 성공적으로 끝난 경우 그 결과를 나타내는 value와 함께 호출\n- `reject(error)` — 에러 발생 시 에러 객체를 나타내는 error와 함께 호출\n- executor는 resolve나 reject 중 하나를 반드시 호출해야 한다.\n\n### 2. 위의 pormise 객체의 내부 프로퍼티 살펴보기\n\n<img src=\"./promise_prop.png\" title=\"pormise 객체의 내부 프로퍼티\" alt=\"promise_property\"></img>  \n참조 : https://ko.javascript.info/\n\n- state : 처음엔 \"pending\" / resolve가 호출되면 _\"fulfilled\"_ / reject가 호출되면 _\"rejected\"_ 로 변한다.\n- result : 처음엔 undefined / resolve(value)가 호출되면 _value_ / reject(error)가 호출되면 _error_ 로 변한다.\n\n---\n\n## 메서드 : then, catch, finally\n\n### 1. then\n\n```javascript\npromise.then(\n  function (result) {\n    /* 프라미스가 이행되었을 때 실행, 실행 결과를 받는다.*/\n  },\n  function (error) {\n    /* 프라미스가 거부되었을 때 실행, 에러를 받는다. */\n  }\n);\n```\n\nex1 ) 성공적으로 이행된 프라미스\n\n```javascript\nlet promise = new Promise(function (resolve, reject) {\n  setTimeout(() => resolve('done!'), 1000);\n});\n\n// resolve 함수는 .then의 첫 번째 함수(인수)를 실행.\npromise.then(\n  (result) => alert(result), // 1초 후 \"done!\"을 출력\n  (error) => alert(error) // 실행되지 않음\n);\n```\n\nex2 ) 에러가 발생한 프라미스\n\n```javascript\nlet promise = new Promise(function (resolve, reject) {\n  setTimeout(() => reject(new Error('에러 발생!')), 1000);\n});\n\n// reject 함수는 .then의 두 번째 함수를 실행.\npromise.then(\n  (result) => alert(result), // 실행되지 않음\n  (error) => alert(error) // 1초 후 \"Error: 에러 발생!\"를 출력\n);\n```\n\n### 2. catch\n\n- 에러가 발생한 경우만 다루고 싶다면 `.catch(errorHandlingFunction)`를 사용한다.\n- `.then(null, errorHandlingFunction)` 과 동일하게 작동한다..\n\n```javascript\nlet promise = new Promise((resolve, reject) => {\n  setTimeout(() => reject(new Error('에러 발생!')), 1000);\n});\n\npromise.catch(alert); // 1초 뒤 \"Error: 에러 발생!\" 출력\n```\n\n### 3. finally\n\n- `.finally(f)` 호출은 `.then(f, f)`과 유사하다.\n\n```javascript\nnew Promise((resolve, reject) => {\n  /* 시간이 걸리는 어떤 일을 수행하고, 그 후 resolve, reject를 호출함 */\n})\n  // 성공·실패 여부와 상관없이 프라미스가 처리되면 실행됨\n  .finally(() => 로딩 인디케이터 중지)\n  .then(result => result와 err 보여줌 => error 보여줌)\n```\n\n---\n\n#### Reference\n\n- https://ko.javascript.info/\n","excerpt":"Promise 기본 메서드 : then, catch, finally Promise 기본 1. promise 객체 생성  — 일이 성공적으로 끝난 경우 그 결과를 나타내는 value와 함께 호출  — 에러 발생 시 에러 객체를 나타내는 error와 함…","fields":{"slug":"/promise.md/"},"frontmatter":{"date":"May 26, 2019","title":"Promise","tags":["JavaScript"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n## constructor\r\n\r\n객체(인스턴스)를 생성하고 클래스 필드를 초기화하기 위한 특수한 메소드  \r\n※ 클래스 필드 : 자바스크립트의 생성자 함수에서 this에 추가한 프로퍼티\r\n\r\n### 1. 예문으로 이해하기\r\n\r\n```javascript\r\n// 클래스 선언문\r\nclass Person {\r\n  // constructor(생성자). 이름을 바꿀 수 없다.\r\n  constructor(name) {\r\n    // this는 클래스가 생성할 인스턴스를 가리킨다.\r\n    // _name은 클래스 필드이다.\r\n    this._name = name;\r\n  }\r\n}\r\n\r\n// 인스턴스 생성\r\nconst me = new Person('Lee');\r\nconsole.log(me); // Person {_name: \"Lee\"}\r\ncs;\r\n```\r\n\r\n- 클래스는 `constructor`라는 이름을 가진 특별한 메서드를 하나씩만 가질 수 있습니다. 2개 이상일 시 `SyntaxError`을 유발합니다.\r\n\r\n- 인스턴스를 생성할 때 new 연산자와 함께 호출한 것이 바로 `constructor`이며 `constructor`의 파라미터에 전달한 값은 클래스 필드에 할당합니다.\r\n\r\n```javascript\r\n// 클래스 선언문\r\nclass Person {}\r\n\r\nconst me = new Person();\r\nconsole.log(me); // Person {}\r\n\r\n// 프로퍼티 동적 할당 및 초기화\r\nme._name = 'daeun';\r\nconsole.log(me); // Person {_name: \"daeun\"}\r\n```\r\n\r\n- `constructor`은 생략할 수 있습니다. 생략하면 클래스에 `constructor( ){ }`를 포함한 것과 동일하게 동작합니다.\r\n\r\n- 따라서 인스턴스에 프로퍼티를 추가하려면 인스턴스를 생성한 이후 프로퍼티를 동적으로 추가해야 합니다.\r\n\r\n```javascript\r\nclass Person {\r\n  constructor(name) {\r\n    this._name = name;\r\n  }\r\n}\r\n\r\nconst me = new Person('daeun');\r\nconsole.log(me);\r\n```\r\n\r\n- `constructor`는 인스턴스의 생성과 동시에 클래스 필드의 생성과 초기화를 실행합니다.\r\n\r\n- 따라서 클래스 필드를 초기화해야 한다면 `constructor`를 생략해서는 안됩니다.\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Classes/constructor\r\n\r\n- https://poiemaweb.com/es6-class\r\n","excerpt":"constructor 객체(인스턴스)를 생성하고 클래스 필드를 초기화하기 위한 특수한 메소드 ※ 클래스 필드 : 자바스크립트의 생성자 함수에서 this에 추가한 프로퍼티 1. 예문으로 이해하기 클래스는 라는 이름을 가진 특별한 메서드를 하나씩만 가질…","fields":{"slug":"/es6-constructor/"},"frontmatter":{"date":"Apr 24, 2019","title":"ES6 Class의 생성자(constructor) 함수","tags":["ES6","JavaScript"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n## GitHub Pages\r\n\r\nGitHub Pages는 GitHub Repository를 이용해 웹 사이트를 무료로 호스팅해주는 서비스입니다.\r\n\r\n- 사용자가 GitHub Repository에 자신의 웹 프로젝트 빌드 결과물을 업로드 하면 GitHub가 그 결과물을 호스팅해 줍니다.\r\n\r\n### 1. 로컬 저장소에 Commit 하기\r\n\r\n```bash\r\n$ git add .\r\n$ git commit -m \" Deploying to Github Pages\"\r\n```\r\n\r\n지금까지 프로젝트의 파일 및 폴더의 추가/변경 사항을 로컬 저장소에 기록합니다.\r\n\r\n### 2. GiHub에 Repository 생성 (원격 저장소 생성)\r\n\r\n<img src=\"./repository.png\" title=\"github_repository\" alt=\"github_repository\" />\r\n\r\n자신의 GitHub에 새로운 repository를 생성합니다\r\n\r\n### 3. 로컬 저장소와 원격 저장소 연결\r\n\r\n원격 저장소의 주소를 입력해 로컬 저장소와 원격 저장소를 연결해 줍니다.\r\n\r\n```bash\r\n$ git remote add origin https://github.com/daeun012/deploy_test.git\r\n```\r\n\r\n로컬 저장소에 기록 한 내용을 원격 저장소에 업로드 합니다.\r\n\r\n```bash\r\n$ git push -u origin master\r\n```\r\n\r\n### 4. gh-pages 패키지 설치\r\n\r\n```bash\r\n$ npm install gh-pages\r\n```\r\n\r\n### 5. package.json 수정\r\n\r\npackage.json 파일에 `\"homepage\": \"https://{GitHub username}.github.io/{Repository name}/\" `을 추가해 주고,\r\n\r\n```json\r\n....\r\n\"browserslist\": {\r\n\"production\": [\r\n\">0.2%\",\r\n\"not dead\",\r\n\"not op_mini all\"\r\n],\r\n\"development\": [\r\n\"last 1 chrome version\",\r\n\"last 1 firefox version\",\r\n\"last 1 safari version\"\r\n]\r\n\r\n},\r\n\"homepage\": \"https://daeun012.github.io/deploy_test/\" //(*)\r\n}\r\n```\r\n\r\n`package.json`의 `\"scripts\"` 부분에 `\"deploy\": \"gh-pages -d build\", \"predeploy\": \"npm run build\"`를 추가해 줍니다.\r\n\r\n```json\r\n...\r\n\"scripts\": {\r\n\"start\": \"react-scripts start\",\r\n\"build\": \"react-scripts build\",\r\n\"test\": \"react-scripts test\",\r\n\"eject\": \"react-scripts eject\",\r\n\"deploy\": \"gh-pages -d build\", //(*)\r\n\"predeploy\": \"npm run build\" //(*)\r\n},\r\n...\r\n```\r\n\r\n- `npm run build` : 현재 프로젝트 코드를 빌드합니다.\r\n\r\n- `gh-pages -d build` : build 디렉토리 (-d)에 있는 파일을 GitHub Pages에 업로드 합니다.\r\n\r\n### 마지막! GitHub Pages에 빌드 결과물 업로드\r\n\r\n```bash\r\n$ npm run deploy\r\n```\r\n\r\nhompage에 입력했던 주소로 접속하시면 프로젝트가 배포된 것을 볼 수 있을 겁니다.\r\n\r\n---\r\n\r\n#### Reference\r\n\r\nhttps://lktprogrammer.tistory.com/5\r\n","excerpt":"GitHub Pages GitHub Pages는 GitHub Repository를 이용해 웹 사이트를 무료로 호스팅해주는 서비스입니다. 사용자가 GitHub Repository에 자신의 웹 프로젝트 빌드 결과물을 업로드 하면 GitHub가 그 결과물…","fields":{"slug":"/github-deploy.md/"},"frontmatter":{"date":"Apr 24, 2019","title":"GitHub Pages로 React 배포(Deploy)하기","tags":["Github","React"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n- DNS란?\r\n- DNS의 작동 원리\r\n\r\n---\r\n\r\n## DNS(Domain Name System)란?\r\n\r\n우리는 인터넷을 이용할 때 웹 브라우저의 주소 창에 도메인 이름을 입력한다. 그러면 브라우저는 우리가 원하는 페이지를 띄어준다.\r\n\r\n하지만 실제 웹 브라우저와 웹 서버는 숫자로 구성된 IP 주소로 통신한다.\r\n\r\n그럼 IP가 아닌 도메인 이름을 입력했는데 어떻게 알아듣고 원하는 페이지를 띄어주는 걸까?\r\n\r\n바로 **사용자가 입력한 도메인 주소**를 **IP주소로 변환해주는 시스템인 DNS를 사용**하기 때문이다.\r\n\r\n---\r\n\r\n## DNS의 작동 원리\r\n\r\n![DNS작동원리](./dns.png)\r\n웹 브라우저는 입력된 도메인 주소의 서버와 통신 하기 위해 DNS 서버와 메시지를 교환해 해당 서버의 IP주소를 획득하고, 사용자의 요청에 따라 원하는 정보들을 받아온다.\r\n\r\n---\r\n\r\n#### Reference\r\n\r\nhttps://opentutorials.org/course/3276/20299\r\n","excerpt":"DNS란? DNS의 작동 원리 DNS(Domain Name System)란? 우리는 인터넷을 이용할 때 웹 브라우저의 주소 창에 도메인 이름을 입력한다. 그러면 브라우저는 우리가 원하는 페이지를 띄어준다. 하지만 실제 웹 브라우저와 웹 서버는 숫자로…","fields":{"slug":"/front-dns.md/"},"frontmatter":{"date":"Mar 06, 2019","title":"DNS와 작동원리","tags":["Front-End"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n## 호스팅(Hosting)\r\n\r\n호스팅의 의미를 알기전에 호스트의 의미를 알아보자,\r\n\r\n### 1. 호스트(Host)란?\r\n\r\n호스트란?**각각의 인터넷에 연결되어 있는 컴퓨터 혹은 장치**들을 가르켜 **호스트**라고 한다.\r\n\r\n### 2. 호스팅이란?\r\n\r\n정보를 제공하는 사업자, 즉 서버 쪽에서 사용되는 컴퓨터 또는 소프트웨어 이러한 것들을 제공하는 사업자를 말한다.  \r\n즉, **우리가 직접 웹서버를 운영하는 일은 쉽지 않기 때문에, 이러한 일을 대신해주는 사업**을 **호스팅**이라고 한다.\r\n\r\n### 3.대표적인 예시\r\n\r\n대표적으로 **웹 호스팅**, **서버 호스팅** 등이 있다.\r\n\r\n- 웹 호스팅 : 웹 애플리케이션을 위한 모든 것을 제공해준다. (웹서버, 미들웨어, 데이터베이스.. 등 모든 것 설치되어있다). 그러기에 웹 애플리케이션만 업로드 하면 된다.\r\n\r\n- 서버 호스팅 : 서버를 운영할 수 있는 컴퓨터만 제공한다. 자기가 원하는 것들을 설치할 수 있어 컴퓨터로 할 수 있는 모든 일을 할 수 있다. 자유도, 활용도가 높지만 직접 자기가 운영해야한다.\r\n\r\n---\r\n\r\n#### Reference\r\n\r\nhttps://opentutorials.org/course/1688/9485\r\n","excerpt":"호스팅(Hosting) 호스팅의 의미를 알기전에 호스트의 의미를 알아보자, 1. 호스트(Host)란? 호스트란?각각의 인터넷에 연결되어 있는 컴퓨터 혹은 장치들을 가르켜 호스트라고 한다. 2. 호스팅이란? 정보를 제공하는 사업자, 즉 서버 쪽에서 사…","fields":{"slug":"/front-hosting/"},"frontmatter":{"date":"Mar 05, 2019","title":"호스팅(Hosting)이란?","tags":["Front-End"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}
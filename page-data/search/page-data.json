{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\r\n- 불 연산하기 : 논리 연산자\r\n- if 조건문 사용하기\r\n- 날짜/시간 활용하기\r\n- 컴퓨터의 조건 - if 조건문으로 짝수와 홀수 구분해보기\r\n\r\n---\r\n\r\n## 불 연산하기 : 논리 연산자\r\n\r\npython에는 논리 연산자를 not, and, or 로 나타냅니다.\r\n\r\n### not 연산자\r\n\r\n`not 연산자`는 피연산자가 하나인 `단항 연산자` 입니다.\r\n\r\n```python\r\n>>> print(not True)\r\nFalse\r\n>>> print(not False)\r\nTrue\r\n>>>\r\n```\r\n\r\n#### not 연산자 조합하기\r\n\r\n```python\r\n>>> x = 10\r\n>>> under_20 = x < 20\r\n>>> print(under_20)\r\nTrue\r\n>>> print(not under_20)\r\nFalse\r\n>>>\r\n```\r\n\r\n### and 연산자와 or 연산자\r\n\r\n```python\r\n>>> print (True and True)\r\nTrue\r\n>>> print (True and False)\r\nFalse\r\n>>> print (False and False)\r\nFalse\r\n>>> print (True or True)\r\nTrue\r\n>>> print (True or False)\r\nTrue\r\n>>> print (False or False)\r\nFalse\r\n```\r\n\r\n---\r\n\r\n## if 조건문 사용하기\r\n\r\nif 조건문의 구조는 다음과 같습니다.\r\n\r\n```\r\nif 조건 :  -> if 조건문 뒤에는 반드시 클론(:)을 붙여주어야 한다.\r\n    문장\r\n    문장\r\n```\r\n\r\n#### 조건문의 기본 사용\r\n\r\n```python\r\nnumber = input(\"정수 입력>\")\r\nnumber = int(number)\r\n\r\nif number > 0:\r\n    print(\"양수입니다.\")\r\n\r\nif number < 0:\r\n    print(\"음수입니다.\")\r\n\r\nif number == 0 :\r\n    print(\"0입니다.\")\r\n```\r\n\r\n▶ 실행결과\r\n\r\n```\r\n정수 입력>273\r\n양수입니다.\r\n\r\n```\r\n\r\n```\r\n\r\n정수 입력>0\r\n0입니다.\r\n\r\n```\r\n\r\n```\r\n\r\n정수 입력>-52\r\n음수입니다.\r\n\r\n```\r\n\r\n---\r\n\r\n## 날짜/시간 활용하기\r\n\r\n#### 날짜/시간 출력하기\r\n\r\n```python\r\nimport datetime # 날짜/시간과 관련된 기능 가져옵니다.\r\n\r\nnow = datetime.datetime.now() # 현재 날짜/시간을 구합니다.\r\n\r\nprint(now.year, \"년\") # 2021 년\r\nprint(now.month, \"월\") # 7 월\r\nprint(now.day, \"일\") # 19 일\r\nprint(now.hour, \"시\") # 13 시\r\nprint(now.minute, \"분\") # 41 분\r\nprint(now.second, \"초\") # 39 초\r\n```\r\n\r\n#### 날짜/시간 한 줄로 출력하기\r\n\r\n```python\r\nimport datetime # 날짜/시간과 관련된 기능 가져옵니다.\r\n\r\nnow = datetime.datetime.now()\r\n\r\nprint(\"{}년 {}월 {}일 {}시 {}분 {}초\".format(\r\n  now.year,\r\n  now.month,\r\n  now.day,\r\n  now.hour,\r\n  now.minute,\r\n  now.second\r\n  ))\r\n```\r\n\r\n▶ 실행결과\r\n\r\n```\r\n2021년 7월 19일 13시 44분 52초\r\n```\r\n\r\n#### 오전과 오후를 구분하는 프로그램\r\n\r\n```python\r\nimport datetime\r\n\r\nnow = datetime.datetime.now()\r\n\r\nif now.hour < 12 :\r\n  print(\"현재 시각은 {}시로 오전입니다!\".format(now.hour))\r\nif now.hour >= 12 :\r\n  print(\"현재 시각은 {}시로 오후입니다!\".format(now.hour))\r\n```\r\n\r\n▶ 실행결과\r\n\r\n```\r\n현재 시각은 13시로 오후입니다!\r\n\r\n```\r\n\r\n#### 계절을 구분하는 프로그램\r\n\r\n```python\r\nimport datetime\r\n\r\nnow = datetime.datetime.now()\r\n\r\nif 3 <= now.month <= 5 :\r\n  print(\"이번 달은 {}월로 봄입니다!\".format(now.month))\r\nif 6 <= now.month <= 8 :\r\n  print(\"이번 달은 {}월로 여름입니다!\".format(now.month))\r\nif 9 <= now.month <= 11 :\r\n  print(\"이번 달은 {}월로 가을입니다!\".format(now.month))\r\nif now.month == 12 or 1 <= now.month <= 2 :\r\n  print(\"이번 달은 {}월로 겨울입니다!\".format(now.month))\r\n```\r\n\r\n▶ 실행결과\r\n\r\n```\r\n이번 달은 7월로 여름입니다!'\r\n```\r\n\r\n---\r\n\r\n## 컴퓨터의 조건 - if 조건문으로 짝수와 홀수 구분해보기\r\n\r\n#### 끝자리로 짝수와 홀수 구분\r\n\r\n```python\r\nnumber = input(\"정수 입력>\")\r\nlast_character = number[-1]\r\nlast_character = int(last_character)\r\n\r\nif last_character == 0 \\\r\n    or last_character == 2 \\\r\n    or last_character == 4 \\\r\n    or last_character == 6 \\\r\n    or last_character == 8 :\r\n    print(\"짝수입니다\")\r\n\r\nif last_character == 1 \\\r\n    or last_character == 3 \\\r\n    or last_character == 5 \\\r\n    or last_character == 7 \\\r\n    or last_character == 9 :\r\n    print(\"짝수입니다\")\r\n```\r\n\r\n파이썬에서 줄이 너무 길어질 때는 \\ 기호를 입력하고 줄바꿈해서 코드를 입력합니다.\r\n\r\n#### in 문자열 연산자를 활용해 짝수와 홀수 구분\r\n\r\n```python\r\nnumber = input(\"정수 입력>\")\r\nlast_character = number[-1]\r\n\r\nif last_character in \"02468\":\r\n    print(\"짝수입니다.\")\r\nif last_character in \"13579\":\r\n    print(\"홀수입니다.\")\r\n```\r\n\r\n#### 나머지 연산자를 활용해서 짝수와 홀수 구분\r\n\r\n```python\r\nnumber = input(\"정수 입력>\")\r\nnumber = int(number)\r\n\r\nif number % 2 == 0 :\r\n    print(\"짝수입니다.\")\r\nif number % 2 == 1 :\r\n    print(\"홀수입니다.\")\r\n```\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- [혼자 공부하는 파이썬](https://www.hanbit.co.kr/store/books/look.php?p_code=B2587075793)\r\n","excerpt":"불 연산하기 : 논리 연산자 if 조건문 사용하기 날짜/시간 활용하기 컴퓨터의 조건 - if 조건문으로 짝수와 홀수 구분해보기 불 연산하기 : 논리 연산자 python에는 논리 연산자를 not, and, or 로 나타냅니다. not 연산자 는 피연산…","fields":{"slug":"/python-study_6/"},"frontmatter":{"date":"Jul 19, 2021","title":"혼자 공부하는 파이썬 - 불 자료형과 if 조건문","tags":["Python"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n- 문자열의 format() 함수\r\n- 대소문자 바꾸기 : upper()와 lower()\r\n- 문자열 양옆의 공백 제거하기 : strip()\r\n- 문자열의 구성 파악하기 : isOO()\r\n- 문자열 찾기 : find()와 rfind()\r\n- 문자열과 in 연산자\r\n- 문자열 자르기 : split()\r\n\r\n---\r\n\r\n## 문자열의 format() 함수\r\n\r\n`format()`함수는 문자열이 가지고 있는 함수 입니다.\r\n다음과 같이 사용할 수 있습니다.\r\n\r\n```\r\n\"{}\".format(52)\r\n\"{} {} {}\".format(52, 20)\r\n\"{} {} {} {} {}\".format(30, 20 ,10 , 15 ,16)\r\n```\r\n\r\n이러한 형태로 앞쪽에 있는 문자열의 {} 기호가 `format()` 함수 괄호 안에 있는 매개 변수로 차례로 대치되면서 문자열이 되는 것 입니다.\r\n\r\n#### 1. format() 함수로 숫자를 문자열로 변환하기\r\n\r\n```python\r\na = \"{}\".format(10)\r\nprint(a) # 10\r\nprint(type(a)) # <class 'str'>\r\n```\r\n\r\n#### 2. format() 함수의 다양한 형태\r\n\r\n```python\r\na = \"{} 만원\".format(10)\r\nb = \"오늘은 {}월 {}일 입니다\".format(7,19)\r\nc = \"{} {} {}\".format(3000, 4000, 5000)\r\nd = \"{} {} {}\".format(1, \"문자열\", True)\r\n\r\nprint(a) # 10 만원\r\nprint(b) # 오늘은 7월 19일 입니다\r\nprint(c) # 3000 4000 5000\r\nprint(d) # 1 문자열 True\r\n```\r\n\r\n### 정수 출력의 다양한 형태\r\n\r\n#### 1. 정수를 특정 칸에 출력하기\r\n\r\n```python\r\n# 정수\r\noutput_a = \"{:d}\".format(52) # {:d}는 int 자료형의 정수를 출력하겠다고 직접적으로 지정하는 것이다. 매개변수로 정수만 올 수 있다.\r\n\r\n# 특정 칸에 출력하기\r\noutput_b = \"{:5d}\".format(52) # 5칸을 잡고 뒤에서 부터 52를 채운다.\r\noutput_c = \"{:10d}\".format(-52)\r\n\r\n# 빈칸을 0으로 채우기\r\noutput_d = \"{:05d}\".format(52) # 5칸을 잡고 뒤에서부터 52라는 숫자를 넣은 후 앞의 빈 곳을 0으로 채운다.\r\noutput_e = \"{:05d}\".format(-52) # 부호가 있을 때는 맨 앞자리를 부호로 채우고 나머지 빈 곳을 0으로 채운다.\r\n\r\nprint('# 기본')\r\nprint(output_a)\r\n\r\nprint('# 특정 칸에 출력하기')\r\nprint(output_b)\r\nprint(output_c)\r\n\r\nprint('# 빈칸을 0으로 채우기')\r\nprint(output_d)\r\nprint(output_e)\r\n```\r\n\r\n▶ 실행결과\r\n\r\n```\r\n# 기본\r\n52\r\n# 특정 칸에 출력하기\r\n   52\r\n       -52\r\n# 빈칸을 0으로 채우기\r\n00052\r\n-0052\r\n```\r\n\r\n#### 2. 기호 붙여 출력하기\r\n\r\n```python\r\noutput_a = \"{:+d}\".format(52)\r\noutput_b = \"{:+d}\".format(-52)\r\noutput_c = \"{: d}\".format(-52)\r\noutput_d = \"{: d}\".format(52)\r\n\r\nprint(output_a)\r\nprint(output_b)\r\nprint(output_c)\r\nprint(output_d)\r\n```\r\n\r\n▶ 실행결과\r\n\r\n```\r\n+52\r\n-52\r\n-52\r\n 52\r\n```\r\n\r\n#### 3. 조합해보기\r\n\r\n```python\r\noutput_a = \"{:+5d}\".format(52)\r\noutput_b = \"{:+5d}\".format(-52)\r\noutput_c = \"{:=+5d}\".format(52)\r\noutput_d = \"{:=+5d}\".format(-52)\r\noutput_e = \"{:+05d}\".format(52)\r\noutput_f = \"{:+05d}\".format(-52)\r\n\r\nprint(output_a)\r\nprint(output_b)\r\nprint(output_c)\r\nprint(output_d)\r\nprint(output_e)\r\nprint(output_f)\r\n```\r\n\r\n▶ 실행결과\r\n\r\n```\r\n  +52\r\n  -52\r\n+  52\r\n-  52\r\n+0052\r\n-0052\r\n```\r\n\r\n### 부동 소수점 출력의 다양한 형태\r\n\r\n#### 1. float 자료형의 기본\r\n\r\n```python\r\noutput_a = \"{:f}\".format(52.273) # {:f}는 float 자료형을 출력하겠다고 직접적으로 지정하는 것이다. 매개변수로 float 자료형만 올 수 있다.\r\noutput_b = \"{:15f}\".format(52.273)\r\noutput_c = \"{:+15f}\".format(52.273)\r\noutput_d = \"{:+015f}\".format(52.273)\r\n\r\nprint(output_a)\r\nprint(output_b)\r\nprint(output_c)\r\nprint(output_d)\r\n```\r\n\r\n▶ 실행결과\r\n\r\n```\r\n52.273000\r\n      52.273000\r\n     +52.273000\r\n+0000052.273000#### 1. float 자료형의 기본\r\n```\r\n\r\n#### 2. 소수점 아래 자릿수 지정하기\r\n\r\n```python\r\noutput_a = \"{:15.3f}\".format(52.273) #{.3f} : 소수점 아래 3번째 자릿수까지 보여준다.\r\noutput_b = \"{:15.2f}\".format(52.273)\r\noutput_c = \"{:15.1f}\".format(52.273)\r\n\r\nprint(output_a)\r\nprint(output_b)\r\nprint(output_c)\r\n```\r\n\r\n▶ 실행결과\r\n\r\n```\r\n         52.273\r\n          52.27\r\n           52.3\r\n```\r\n\r\n자동으로 반올림이 일어나는 것을 확인 할 수 있습니다.\r\n\r\n#### 3. 의미 없는 소수점 제거하기\r\n\r\n```python\r\noutput_a = 52.0\r\noutput_b = \"{:g}\".format(ouput_a) # 의미 없는 0을 제거 하고 싶을 땐 {:g}를 사용한다.\r\n\r\nprint(output_a)\r\nprint(output_b)\r\n```\r\n\r\n▶ 실행결과\r\n\r\n```\r\n52.0\r\n52\r\n```\r\n\r\n### IndexError 살펴보기\r\n\r\n{} 기호의 개수가 `format()` 함수의 매개변수 개수보다 많으면 `IndexError 예외`가 발생합니다.\r\n\r\n```python\r\n>>> \"{} {}\".format(1, 2, 3, 4) # {} 보다 매개변수 개수가 많을 때는 예외가 발생하지 않습니다. {} 개수만큼 적용되고 나머지 매개변수는 버려집니다.\r\n'1 2'\r\n>>> \"{} {} {}\".format(1, 2)\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nIndexError: Replacement index 2 out of range for positional args tuple\r\n```\r\n\r\n---\r\n\r\n## 대소문자 바꾸기 : upper()와 lower()\r\n\r\n- `upper()` : 문자열의 알파벳을 대문자로 만든다.\r\n- `lower()` : 문자열의 알파벳을 소문자로 만든다.\r\n\r\n```python\r\n>>> a = \"Hello Python Programming...!\"\r\n>>> a.upper()\r\n'HELLO PYTHON PROGRAMMING...!'\r\n```\r\n\r\n```python\r\n>>> a = \"Hello Python Programming...!\"\r\n>>> a.lower()\r\n'hello python programming...!'\r\n```\r\n\r\n---\r\n\r\n## 문자열 양옆의 공백 제거하기 : strip()\r\n\r\n- `strip()` : 문자열 양옆의 공백을 제거한다.\r\n- `rstrip()` : 문자열 오른쪽 공백을 제거한다.\r\n- `lstrip()` : 문자열 왼쪽 공백을 제거한다.\r\n\r\n```python\r\n>>> input_a = \"\"\"\r\n...              안녕하세요\r\n... 문자열의 함수를 알아봅시다.\r\n... \"\"\"\r\n>>> print(input_a)\r\n\r\n             안녕하세요\r\n문자열의 함수를 알아봅시다.\r\n\r\n>>> print(input_a.strip())\r\n안녕하세요\r\n문자열의 함수를 알아봅시다.\r\n```\r\n\r\n---\r\n\r\n## 문자열의 구성 파악하기 : isOO()\r\n\r\n문자열이 소문자로만 구성되어 있는지, 알파벳 또는 숫자로만 구성되어 있는지 등을 확인할 때는 is로 시작하는 이름의 함수를 사용합니다.\r\n\r\n- `isalnum()` : 문자열이 알파벳 또는 숫자로만 구성되어 있는지 확인합니다.\r\n- `isalpha()` : 문자열이 알파벳으로만 구성되어 있는지 확인합니다.\r\n- `isdentifier()` : 문자열이 식별자로 사용할 수 있는 것인지 확인합니다.\r\n- `isdecimal()` : 문자열이 정수 형태인지 확인합니다.\r\n- `isdigit()` : 문자열이 숫자로 인식될 수 있는 것인지 확인합니다.\r\n- `isspace()` : 문자열이 공백으로만 구성되어 있는지 확인합니다.\r\n- `islower()` : 문자열이 소문자로만 구성되어 있는지 확인합니다.\r\n- `isupper()` : 문자열이 대문자로만 구성되어 있는지 확인합니다.\r\n\r\n```python\r\n>>> print(\"TrainA10\".isalnum())\r\nTrue\r\n>>> print(\"10\".isalnum())\r\nTrue\r\n>>> print(\"TrainA10\".isdigit())\r\nFalse\r\n```\r\n\r\nTrue 또는 False를 출력합니다.\r\n\r\n---\r\n\r\n## 문자열 찾기 : find()와 rfind()\r\n\r\n- `find()` : 왼쪽부터 찾아서 처음 등장하는 위치를 찾습니다.\r\n- `rfind()` : 오른쪽부터 찾아서 처음 등장하는 위치를 찾습니다.\r\n\r\n```python\r\n>>> output_a = \"안녕안녕하세요\".find(\"안녕\")\r\n>>> print(output_a)\r\n0\r\n\r\n>>> output_b = \"안녕안녕하세요\".rfind(\"안녕\")\r\n>>> print(output_b)\r\n2\r\n```\r\n\r\n```\r\n0  1  2  3  4  5  6\r\n안 녕 안 녕 하 세 요\r\n```\r\n\r\n처음 \"안녕\"은 0번째에 있는 것이고,  \r\n두 번째 \"안녕\"은 2번째부터 등장해 저러한 결과가 나옵니다.\r\n\r\n---\r\n\r\n## 문자열 자르기 : split()\r\n\r\n```python\r\n>>> a = \"10 20 30 40 50\".split(\" \")\r\n>>> print(a)\r\n['10', '20', '30', '40', '50']\r\n```\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- [혼자 공부하는 파이썬](https://www.hanbit.co.kr/store/books/look.php?p_code=B2587075793)\r\n","excerpt":"문자열의 format() 함수 대소문자 바꾸기 : upper()와 lower() 문자열 양옆의 공백 제거하기 : strip() 문자열의 구성 파악하기 : isOO() 문자열 찾기 : find()와 rfind() 문자열과 in 연산자 문자열 자르기 :…","fields":{"slug":"/python-study_5/"},"frontmatter":{"date":"Jul 19, 2021","title":"혼자 공부하는 파이썬 - 숫자와 문자열의 다양한 함수","tags":["Python"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n- if~else 조건문 사용하기\r\n- elif 구문\r\n- False로 변환되는 값\r\n- pass 키워드\r\n\r\n---\r\n\r\n## if~else 조건문 사용하기\r\n\r\nif~else 조건문의 구조는 다음과 같습니다.\r\n\r\n```\r\nif 조건 :\r\n    조건이 참일 때 실행할 문장\r\nelse :\r\n    조건이 거짓일 때 실행할 문장\r\n```\r\n\r\n#### if~else 조건문으로 짝수와 홀수 구분하기\r\n\r\n```python\r\nnumber = input(\"정수 입력>\")\r\nnumber = int(number)\r\n\r\nif number % 2 == 0 :\r\n  print(\"짝수입니다\")\r\nelse :\r\n  print(\"홀수입니다.\")\r\n```\r\n\r\n---\r\n\r\n## elif 구문\r\n\r\n조건이 세 개 이상일 때 사용하는 구문입니다.  \r\nelif 구문의 구조는 다음과 같습니다.\r\n\r\n```\r\nif 조건A :\r\n    조건A가 참일 때 실행할 문장\r\nelif 조건B :\r\n    조건B가 참일 때 실행할 문장\r\nelif 조건C :\r\n    조건C가 참일 때 실행할 문장\r\n...\r\nelse :\r\n    모든 조건이 거짓일 때 문장\r\n```\r\n\r\n#### 계절구하기\r\n\r\n```python\r\nimport datetime\r\n\r\nnow = datetime.datetime.now()\r\n\r\nif 3 <= now.month <= 5 :\r\n  print(\"이번 달은 {}월로 봄입니다!\".format(now.month))\r\nelif 6 <= now.month <= 8 :\r\n  print(\"이번 달은 {}월로 여름입니다!\".format(now.month))\r\nelif 9 <= now.month <= 11 :\r\n  print(\"이번 달은 {}월로 가을입니다!\".format(now.month))\r\nelse :\r\n  print(\"이번 달은 {}월로 겨울입니다!\".format(now.month))\r\n```\r\n\r\n---\r\n\r\n## False로 변환되는 값\r\n\r\nif 조건문의 매개변수에 불이 아닌 다른 값이 올 때는 자동으로 이를 불로 변환해 처리합니다.\r\n예제를 통해 이를 살펴보겠습니다.\r\n\r\n#### False로 변환되는 값\r\n\r\n```python\r\nif 0 :\r\n    print(\"0은 True로 변환됩니다.\")\r\nelse :\r\n    print(\"0은 False로 변환됩니다.\")\r\n\r\nif \"\" :\r\n    print(\"빈 문자열은 True로 변환됩니다.\")\r\nelse :\r\n    print(\"빈 문자열은 False로 변환됩니다.\")\r\n```\r\n\r\n▶ 실행결과\r\n\r\n```\r\n0은 False로 변환됩니다.\r\n빈 문자열은 False로 변환됩니다.\r\n```\r\n\r\n---\r\n\r\n## pass 키워드\r\n\r\n#### 나중에 구현하려고 비워둔 구문\r\n\r\n```python\r\nnumber = input(\"정수 입력>\")\r\nnumber = int(number)\r\n\r\nif number > 0 :\r\n  # 양수일 때 : 아직 미구현 상태\r\nelse :\r\n  # 음수일 때 : 아직 미구현 상태\r\n```\r\n\r\n▶ 실행결과\r\n\r\n```\r\nIndentationError: expected an indented block\r\n```\r\n\r\n오류가 발생합니다. 그렇기 때문에 if 구문 사이에는 어떤 내용이라도 넣어 줘야 합니다.  \r\n그래서 파이썬은 이를 해결하기 위해 `pass`라는 키워드를 제공합니다.\r\n\r\n#### pass 키워드를 사용한 미구현 부분 입력\r\n\r\n```python\r\nnumber = input(\"정수 입력>\")\r\nnumber = int(number)\r\n\r\nif number > 0 :\r\n  # 양수일 때 : 아직 미구현 상태\r\n  pass\r\nelse :\r\n  # 음수일 때 : 아직 미구현 상태\r\n  pass\r\n```\r\n\r\n코드를 살펴보던 도중 `pass` 키워드를 만나면  \r\n\"진짜로 아무것도 안함\" 또는 \"곧 개발하겠음\"이라는 의미로 생각하면 됩니다.\r\n\r\n## raise NotImplementedError\r\n\r\n`pass` 키워드를 입력해 놨어도 내일이면 잊어버리는 경우가 많습니다.\r\n그래서 `raise` 키워드와 미구현 상태를 표현하는 `NotImplementedError`을 조합해  \r\n`raise NotImplementedError`를 사용하면 \"아직 구현하지 않은 부분이에요!\"라는 오류를 강제로 발생시킬 수 있습니다.\r\n\r\n```python\r\nnumber = input(\"정수 입력>\")\r\nnumber = int(number)\r\n\r\nif number > 0 :\r\n  # 양수일 때 : 아직 미구현 상태\r\n  raise NotImplementedError\r\nelse :\r\n  # 음수일 때 : 아직 미구현 상태\r\n  raise NotImplementedError\r\n```\r\n\r\n▶ 실행결과\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"c:\\Users\\다은\\Desktop\\test\\format3.py\", line 6, in <module>\r\n    raise NotImplementedError\r\nNotImplementedError\r\n```\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- [혼자 공부하는 파이썬](https://www.hanbit.co.kr/store/books/look.php?p_code=B2587075793)\r\n","excerpt":"if~else 조건문 사용하기 elif 구문 False로 변환되는 값 pass 키워드 if~else 조건문 사용하기 if~else 조건문의 구조는 다음과 같습니다. if~else 조건문으로 짝수와 홀수 구분하기 elif 구문 조건이 세 개 이상일 때…","fields":{"slug":"/python-study_7/"},"frontmatter":{"date":"Jul 19, 2021","title":"혼자 공부하는 파이썬 - if~else와 elif 구문","tags":["Python"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n- 변수 선언과 할당\r\n- 복합 대입 연산자\r\n- 사용자 입력 : input()\r\n- 문자열을 숫자로 바꾸기\r\n- 숫자를 문자열로 바꾸기\r\n\r\n---\r\n\r\n## 변수 선언과 할당\r\n\r\n파이썬은 변수의 자료형에 대해 미리 선언해 주지 않아도 된다.  \r\n`pi = 3.14 ` 이렇게 간단하게 변수를 만들 수 있다!\r\n\r\n```python\r\n>>> pi = 3.1415926\r\n>>> pi+2\r\n5.1415926\r\n```\r\n\r\n---\r\n\r\n## 복합 대입 연산자\r\n\r\n+= : 숫자 덧셈 후 대입  \r\n-= : 숫자 뺄셈 후 대입  \r\n\\*= : 숫자 곱셈 후 대입  \r\n/= : 숫자 나눗셈 후 대입  \r\n%= : 수자의 나머지를 구한 후 대입  \r\n\\*\\*= : 숫자 제곱 후 대입\r\n\r\n```python\r\n>>> number = 100\r\n>>> number += 10\r\n>>> number += 20\r\n>>> print('number:', number)\r\nnumber: 130\r\n```\r\n\r\n숫자 뿐만 아니라 문자열에도 사용할 수 있다.\r\n\r\n```python\r\n>>> string = \"안녕하세요\"\r\n>>> string += \"!\"\r\n>>> string += \"!\"\r\n>>> print('string:', string)\r\nstring: 안녕하세요!!\r\n```\r\n\r\n---\r\n\r\n## 사용자 입력 : input()\r\n\r\n#### 1. `input()` 함수로 사용자로부터의 입력을 받아 낼 수 있다.\r\n\r\n```python\r\n>>> input(\"인사말을 입력하세요 >>\")\r\n인사말을 입력하세요 >> 안녕하세요!\r\n' 안녕하세요!'\r\n```\r\n\r\n#### 2. 사용자가 입력한 내용은 `input()` 함수의 결과로 나온다.\r\n\r\n이 값은 다른 변수에 대입해 사용 할 수 있다.\r\n\r\n```python\r\n>>> string = input(\"인사말을 입력하세요 >>\")\r\n인사말을 입력하세요 >> 안녕하세요!!!!!!!\r\n>>> print(string)\r\n 안녕하세요!!!!!!!\r\n```\r\n\r\n#### 3. `input()` 함수의 결과의 자료형은 무조건 str! 문자열이다.\r\n\r\n```python\r\n>>> string = input(\"인사말을 입력하세요 >>\")\r\n인사말을 입력하세요 >> 안녕하세요!!!!!!!\r\n>>> print(string)\r\n 안녕하세요!!!!!!!\r\n>>> print(type(string))\r\n<class 'str'>\r\n\r\n\r\n>>> number = input(\"숫자를 입력하세요 >>\")\r\n숫자를 입력하세요 >>123456\r\n>>> print(number)\r\n123456\r\n>>> print(tpye(number))\r\n<class 'str'>\r\n```\r\n\r\n---\r\n\r\n## 문자열을 숫자로 바꾸기\r\n\r\ninput() 함수의 입력 자료형은 항상 문자열이기 때문에 입력받은 문자열을 수자로 변환해야 숫자 연산에 활용할 수 있다.\r\n이를 **캐스트(cast)** 라고 부른다.\r\n\r\n- int() : 문자열을 int 자료형으로 변환\r\n- float() : 문자열을 float 자료형으로 변환\r\n\r\n```python\r\nstring_a=input(\"입력A> \")\r\nint_a=int(string_a)\r\n\r\nstring_b=input(\"입력B> \")\r\nint_b=int(string_b)\r\n\r\nprint(\"문자열 자료:\", string_a+string_b)\r\nprint(\"숫자 자료:\", int_a+int_b)\r\n```\r\n\r\n▶ 실행결과\r\n\r\n```python\r\n입력A> 273\r\n입력B> 52\r\n문자열 자료: 27352\r\n숫자 자료: 325\r\n```\r\n\r\n### ValueError 살펴보기\r\n\r\n자료형을 변환할 때 **변환할 수 없는 것**을 변환하려 하면 `ValueError` 예외가 발생한다.  \r\n이러한 예외가 발생하는 경우는 두 가지가 있다.\r\n\r\n#### 1. 숫자가 아닌 것을 숫자로 변환하려 할 때\r\n\r\n```python\r\nint(\"안녕하세요\")\r\nfloat(\"반갑습니다\")\r\n```\r\n\r\n이와 같은 오류를 볼 수 있다.\r\n\r\n```python\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nValueError: invalid literal for int() with base 10: '안녕하세요'\r\n```\r\n\r\n#### 2. 소수점이 있는 숫자 형식의 문자열을 int() 함수로 변환하려고 할 때\r\n\r\n```python\r\nint(\"3.145\")\r\n```\r\n\r\n이와 같은 오류를 볼 수 있다.\r\n\r\n```python\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nValueError: invalid literal for int() with base 10: '3.145'\r\n```\r\n\r\n---\r\n\r\n## 숫자를 문자열로 바꾸기\r\n\r\n`str()` 함수를 사용해 숫자를 문자열로 변환할 수 있다.\r\n\r\n```python\r\noutput_a = str(52)\r\noutput_b = str(52.273)\r\nprint(type(output_a), output_a)\r\nprint(type(output_b), output_b)\r\n```\r\n\r\n▶ 실행결과\r\n\r\n```python\r\n<class 'str'> 52\r\n<class 'str'> 52.273\r\n```\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- [혼자 공부하는 파이썬](https://www.hanbit.co.kr/store/books/look.php?p_code=B2587075793)\r\n","excerpt":"변수 선언과 할당 복합 대입 연산자 사용자 입력 : input() 문자열을 숫자로 바꾸기 숫자를 문자열로 바꾸기 변수 선언과 할당 파이썬은 변수의 자료형에 대해 미리 선언해 주지 않아도 된다.  이렇게 간단하게 변수를 만들 수 있다! 복합 대입 연산…","fields":{"slug":"/python-study_4/"},"frontmatter":{"date":"Jul 18, 2021","title":"혼자 공부하는 파이썬 - 변수와 입력","tags":["Python"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n- 숫자의 종류\r\n- 숫자 연산자\r\n\r\n---\r\n\r\n## 숫자의 종류\r\n\r\n파이썬의 숫자에는 두 가지 종류가 있다.\r\n\r\n- 정수(integer) : 소수점이 없는 숫자 0, 1, 3, 456 ...\r\n- 실수(float) : 소수점이 있는 숫자 0.2, 52.74, -1.2 ...\r\n\r\n```python\r\n>>> print(type(273))\r\n<class 'int'>\r\n>>> print(type(276.52))\r\n<class 'float'>\r\n```\r\n\r\n---\r\n\r\n## 숫자 연산자\r\n\r\n### 1. 사칙 연산자 : +, -, \\*, /\r\n\r\n### 2. 정수 나누기 연산자 : //\r\n\r\n숫자를 나누고 소수점 이하의 자릿수를 떼어 버린 후, 정수 부분만 남기는 연산자 이다.\r\n\r\n```python\r\n>>> print(\"3 / 2 =\", 3/2)\r\n3 / 2 = 1.5\r\n>>> print(\"3 // 2 =\", 3//2)\r\n3 // 2 = 1\r\n```\r\n\r\n### 3. 나머지 연산자 : %\r\n\r\n```python\r\n>>>  print(\"5 % 2 =\", 5%2)\r\n5 % 2 = 1\r\n```\r\n\r\n### 4. 제곱 연산자 : \\*\\*\r\n\r\n```python\r\n>>> print(\"5 ** 2 =\", 5**2)\r\n5 ** 2 = 25\r\n>>> print(\"5 ** 3 =\", 5**3)\r\n5 ** 3 = 125\r\n>>> print(\"5 ** 4 =\", 5**4)\r\n5 ** 4 = 625\r\n```\r\n\r\n### TypeError 살펴보기\r\n\r\n```python\r\n>>> print(\"안녕\"+1)\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nTypeError: can only concatenate str (not \"int\") to str\r\n```\r\n\r\n문자열과 숫자를 +연산자로 연결할 수 없다.  \r\n문자열은 문자열끼리\r\n숫자는 숫자끼리\r\n연산이 가능하다.\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- [혼자 공부하는 파이썬](https://www.hanbit.co.kr/store/books/look.php?p_code=B2587075793)\r\n","excerpt":"숫자의 종류 숫자 연산자 숫자의 종류 파이썬의 숫자에는 두 가지 종류가 있다. 정수(integer) : 소수점이 없는 숫자 0, 1, 3, 456 ... 실수(float) : 소수점이 있는 숫자 0.2, 52.74, -1.2 ... 숫자 연산자 1.…","fields":{"slug":"/python-study_3/"},"frontmatter":{"date":"Jul 17, 2021","title":"혼자 공부하는 파이썬 - 숫자","tags":["Python"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n- 자료형 확인하기\r\n- 문자열 연산자\r\n- 문자열의 길이 구하기\r\n\r\n---\r\n\r\n## 자료형 확인하기\r\n\r\n파이썬에서 자료의 형식을 확인할 때는 `type()` 함수를 사용한다.\r\n\r\n```python\r\n>>> print(type(\"안녕하세요\"))\r\n<class 'str'>\r\n>>> print(type(2763))\r\n<class 'int'>\r\n```\r\n\r\n---\r\n\r\n## 문자열 연산자\r\n\r\n프로그래밍 언어에서 이름을 붙일 때 사용하는 단어\r\n\r\n### 1. 문자열 연결 연산자 : +\r\n\r\n두 문자열을 연결해 새로운 문자열을 만든다\r\n\r\n```python\r\n>>> print(\"안녕\" +\"하세요\")\r\n안녕하세요\r\n>>> print(\"안녕하세요\" +\"!\")\r\n안녕하세요!\r\n```\r\n\r\n문자열과 숫자의 연결은 불가능하다.\r\n\r\n```python\r\n>>> print(\"안녕\" + 1)\r\n```\r\n\r\n### 2. 문자열 반복 연산자 : \\*\r\n\r\n문자열을 숫자와 \\* 연산자로 연결하면 문자열을 반복할 수 있다.\r\n\r\n```python\r\n>>> print(\"안녕\" *3)\r\n안녕안녕안녕\r\n```\r\n\r\n### 3. 문자열 선택 연산자(인덱싱) : []\r\n\r\n문자열 내부의 문자 하나를 선택하는 연산자이다.\r\n\r\n```python\r\n>>> print(\"안녕하세요\"[0])\r\n안\r\n>>> print(\"안녕하세요\"[1])\r\n녕\r\n>>> print(\"안녕하세요\"[2])\r\n하\r\n>>> print(\"안녕하세요\"[3])\r\n세\r\n>>> print(\"안녕하세요\"[-1])\r\n요\r\n>>> print(\"안녕하세요\"[-2])\r\n세\r\n```\r\n\r\n### 4. 문자열 범위 선택 연산자(슬라이싱) : [:]\r\n\r\n문자열의 특정 범위를 선택할 때 사용하는 연산자\r\n\r\n```python\r\n>>> print(\"안녕하세요\"[1:4])\r\n녕하세\r\n>>> print(\"안녕하세요\"[0:2])\r\n안녕\r\n>>> print(\"안녕하세요\"[1:3])\r\n녕하\r\n>>> print(\"안녕하세요\"[1:])\r\n녕하세요\r\n>>> print(\"안녕하세요\"[:3])\r\n안녕하\r\n```\r\n\r\n---\r\n\r\n## 문자열의 길이 구하기\r\n\r\n문자열의 길이를 구할 때는 `len()` 함수를 사용한다.\r\n\r\n```python\r\n>>> print(len(\"Hello Python!\"))\r\n13\r\n```\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- [혼자 공부하는 파이썬](https://www.hanbit.co.kr/store/books/look.php?p_code=B2587075793)\r\n","excerpt":"자료형 확인하기 문자열 연산자 문자열의 길이 구하기 자료형 확인하기 파이썬에서 자료의 형식을 확인할 때는  함수를 사용한다. 문자열 연산자 프로그래밍 언어에서 이름을 붙일 때 사용하는 단어 1. 문자열 연결 연산자 : + 두 문자열을 연결해 새로운 …","fields":{"slug":"/python-study_2/"},"frontmatter":{"date":"Jul 16, 2021","title":"혼자 공부하는 파이썬 - 자료형과 문자열","tags":["Python"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n- 키워드란?\r\n- 식별자란?\r\n- 주석\r\n- 출력 : print()\r\n\r\n---\r\n\r\n## 키워드란?\r\n\r\n특별한 의미가 부여된 단어  \r\n파이썬이 만들어질 때 이미 사용하겠다고 예약해 놓은 것이다.\r\n\r\n### 1. 왜 알아야할까?\r\n\r\n변수나 함수의 이름을 정할 때 키워드를 사용하면 안 되기 때문에, 알아두는 것이 좋다.\r\n\r\n### 2. 파이썬의 키워드 확인해보기\r\n\r\n```python\r\n>>> import keyword\r\n>>> print(keyword.kwlist)\r\n```\r\n\r\n다음과 같은 키워드들을 확인할 수 있다.\r\n\r\n＊ 파이썬은 대문자와 소문자를 구분한다.\r\n\r\n```python\r\n['False', 'None', 'True', '__peg_parser__', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']\r\n```\r\n\r\n---\r\n\r\n## 식별자란?\r\n\r\n프로그래밍 언어에서 이름을 붙일 때 사용하는 단어\r\n\r\n### 1. 식별자의 규칙\r\n\r\n- 키워드를 사용하면 안된다.\r\n- 특수 문자는 언더 바(\\_)만 허용된다.\r\n- 숫자로 시작하면 안된다.\r\n- 공백을 포함할 수 없다.\r\n\r\n### 2. 파이썬의 표기법 - 스네이크 케이스와 캐멀 케이스\r\n\r\n파이썬은 대표적으로 **스네이크 케이스**와 **캐멀 케이스** 표기법을 사용한다.\r\n\r\n#### 스네이크 케이스\r\n\r\n단어 사이에 언더 바(\\_) 기호를 붙여 표기한다.  \r\n ex) item_list, login_status, rotate_angle\r\n\r\n#### 캐멀 케이스\r\n\r\n단어들의 첫 글자를 대문자로 만들어 표기한다.  \r\n ex) ItemList, LoginStatus, RotateAngle\r\n\r\n---\r\n\r\n## 주석\r\n\r\n```python\r\n>>> # 앞에 샵 기호를 붙여 주석 처리를 합니다.\r\n>>> print(\"Hello Python!\") # 문자열을 출력합니다.\r\n```\r\n\r\n---\r\n\r\n## 출력 : print()\r\n\r\nPython 에서의 출력은 print() 함수를 사용하는 것이다.\r\n\r\n```python\r\n>>> print(\"Hello Python!\")\r\nHello Python!\r\n>>> print(\"Hello Python!\",52,57)\r\nHello Python! 52 57\r\n>>> print()\r\n\r\n>>>\r\n```\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- [혼자 공부하는 파이썬](https://www.hanbit.co.kr/store/books/look.php?p_code=B2587075793)\r\n","excerpt":"키워드란? 식별자란? 주석 출력 : print() 키워드란? 특별한 의미가 부여된 단어 파이썬이 만들어질 때 이미 사용하겠다고 예약해 놓은 것이다. 1. 왜 알아야할까? 변수나 함수의 이름을 정할 때 키워드를 사용하면 안 되기 때문에, 알아두는 것이…","fields":{"slug":"/python-study_1/"},"frontmatter":{"date":"Jul 16, 2021","title":"혼자 공부하는 파이썬 - Python 용어 정리","tags":["Python"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n- 버블 정렬(Bubble Sort)이란?\r\n- 버블 정렬 살펴보기\r\n- 버블 정렬 실행해보기 with 자바스크립트\r\n\r\n---\r\n\r\n## 버블 정렬(Bubble Sort)이란?\r\n\r\n서로 인접한 두 원소를 검사해 정렬하는 알고리즘이다.\r\n\r\n- 오름차순을 기준으로 정렬한다.\r\n- 큰 숫자가 왼쪽에서 오른쪽을 향해 거품처럼 이동하는 모습\r\n\r\n## 버블 정렬 살펴보기\r\n\r\n- 이웃한 데이터의 값을 비교해 값의 크기가 다르면 위치를 바꾼다\r\n- 오름차순으로 정렬할 경우 왼쪽 데이터의 크기가 오른쪽 데이터의 크기보다 크면 위치를 바꾼다.\r\n\r\n![실행 화면](./bubbleSortEx.png)\r\n\r\n### 계산량 확인해보기\r\n\r\n데이터의 총 개수를 n이라고 하면 버블 정렬의 비교 횟수는\r\n처음에 n-1 번, 그 다음은 n-2, n-3 번 ... 이다.\r\n\r\n반복 횟수는 (n-1) + (n-2) + (n-3) + ... + 1 이므로 (n²-n)/2이다.  \r\n즉 버블 정렬의 오더는 O(n²)이 된다.\r\n\r\n## 버블 정렬 실행해보기 with 자바스크립트\r\n\r\n```html\r\n<!-- html -->\r\n<form name=\"inputForm\">\r\n  <div>버블 정렬</div>\r\n  <div>\r\n    <input name=\"str\" size=\"50\" type=\"text\" />\r\n    <input type=\"button\" value=\"정렬하기\" onClick=\"doSort()\" />\r\n  </div>\r\n</form>\r\n<form name=\"outputForm\">\r\n  <div>정렬 결과</div>\r\n  <div><textarea name=\"result\" cols=\"50\" rows=\"20\"></textarea></div>\r\n</form>\r\n```\r\n\r\n```javascript\r\n// javascript\r\nfunction doSort() {\r\n  let inputForm = document.forms.inputForm;\r\n  let outputForm = document.forms.outputForm;\r\n  let ary = inputForm.str.value.split(',');\r\n  ary = ary.map((e) => Number(e));\r\n  outputForm.result.value = ary.join(' ') + '\\n';\r\n  outputForm.result.value = outputForm.result.value + '----' + '\\n';\r\n  bubbleSort(ary);\r\n  outputForm.result.value = outputForm.result.value + '----' + '\\n';\r\n  printAry(ary);\r\n  outputForm.result.value = outputForm.result.value + 'done!' + '\\n';\r\n\r\n  function bubbleSort(ary) {\r\n    let i = 0;\r\n    while (i < ary.length - 1) {\r\n      let j = 0;\r\n      while (j < ary.length - i - 1) {\r\n        if (ary[j] > ary[j + 1]) {\r\n          let n = ary[j];\r\n          ary[j] = ary[j + 1];\r\n          ary[j + 1] = n;\r\n        }\r\n        j++;\r\n        printAry(ary);\r\n      }\r\n      i++;\r\n    }\r\n  }\r\n\r\n  function printAry(ary) {\r\n    outputForm.result.value = outputForm.result.value + ary.join(' ') + '\\n';\r\n  }\r\n}\r\n```\r\n\r\n### 실행 화면\r\n\r\n![실행 화면](./bubbleSort.png)\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- [모두의 알고리즘 with 자바스크립트](https://www.gilbut.co.kr/book/view?bookcode=BN002328)\r\n","excerpt":"버블 정렬(Bubble Sort)이란? 버블 정렬 살펴보기 버블 정렬 실행해보기 with 자바스크립트 버블 정렬(Bubble Sort)이란? 서로 인접한 두 원소를 검사해 정렬하는 알고리즘이다. 오름차순을 기준으로 정렬한다. 큰 숫자가 왼쪽에서 오른…","fields":{"slug":"/bubble-sort.md/"},"frontmatter":{"date":"Jul 12, 2021","title":"버블 정렬(Bubble Sort)","tags":["Argorithm","JavaScript"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n- 퀵 정렬(Quick Sort)이란?\r\n- 퀵 정렬 살펴보기\r\n- 퀵 정렬 실행해보기 with 자바스크립트\r\n\r\n---\r\n\r\n## 퀵 정렬(Quick Sort)이란?\r\n\r\n데이터의 범위를 반으로 나눈 다음, 그 범위를 다시 반으로 나누어 정렬하는 처리를 반복한다.\r\n\r\n## 퀵 정렬 살펴보기\r\n\r\n- 우선 피봇(기준 값)을 정한다. 피봇으로 정할 데이터는 어떤 데이터든 상관없다.\r\n- 정렬한 데이터의 크기가 피봇보다 큰 그룹과 작은 그룹으로 분할한다.\r\n- 나눈 그룹 안에서도 똑같이 피붓을 정한 후 위와 같은 방식으로 분할한다.\r\n- 이처럼 분할을 반복해 정렬하는 알고리즘을 `분할 정복 알고리즘`이라고 한다\r\n\r\n![실행 화면](./quickSortEx.png)\r\n\r\n### 계산량 확인해보기\r\n\r\n퀵 정렬은 피봇을 기준으로 한 데이터의 크기에 따라 전체 데이터를 균형 있게 절반씩 분할해 나가며,  \r\n그 결과로 log₂n단 만들어진다.  \r\n오더는 O(nlogn)이다.  \r\n하지만 데이터를 나열한 순서가 좋지 않으면 효율이 나빠지고, 최악의 경우에는 오더가 O(n²)이 될 수 있다.\r\n\r\n## 퀵 정렬 실행해보기 with 자바스크립트\r\n\r\n```html\r\n<!-- html -->\r\n<form name=\"inputForm\">\r\n  <div>퀵 정렬</div>\r\n  <div>\r\n    <input name=\"str\" size=\"50\" type=\"text\" />\r\n    <input type=\"button\" value=\"정렬하기\" onClick=\"doSort()\" />\r\n  </div>\r\n</form>\r\n<form name=\"outputForm\">\r\n  <div>정렬 결과</div>\r\n  <div><textarea name=\"result\" cols=\"50\" rows=\"20\"></textarea></div>\r\n</form>\r\n```\r\n\r\n```javascript\r\n// javascript\r\nfunction doSort() {\r\n  let inputForm = document.forms.inputForm;\r\n  let outputForm = document.forms.outputForm;\r\n  let ary = inputForm.str.value.split(',');\r\n  ary = ary.map(function (e) {\r\n    return Number(e);\r\n  });\r\n  outputForm.result.value = ary.join(' ') + '\\n';\r\n  outputForm.result.value = outputForm.result.value + '---' + '\\n';\r\n  quickSort(ary);\r\n  outputForm.result.value = outputForm.result.value + '---' + '\\n';\r\n  printAry(ary);\r\n  outputForm.result.value = outputForm.result.value + 'done!' + '\\n';\r\n\r\n  function quickSort(ary) {\r\n    function sort(start, end) {\r\n      if (start >= end) {\r\n        return;\r\n      }\r\n      let left = start;\r\n      let right = end;\r\n      let ref = ary[Math.round((left + right) / 2)];\r\n      while (left < right) {\r\n        if (ary[left] >= ref) {\r\n          while (right > left) {\r\n            if (ary[right] <= ref) {\r\n              let n = ary[left];\r\n              ary[left] = ary[right];\r\n              ary[right] = n;\r\n              right = right - 1;\r\n              break;\r\n            }\r\n            right = right - 1;\r\n          }\r\n          printAry(ary);\r\n        }\r\n        left = left + 1;\r\n      }\r\n      if (ary[right] > ref) {\r\n        sort(start, right - 1);\r\n        sort(right, end);\r\n      } else if (ary[right] < ref) {\r\n        sort(start, right);\r\n        sort(right + 1, end);\r\n      } else {\r\n        sort(start, right - 1);\r\n        sort(right + 1, end);\r\n      }\r\n    }\r\n    sort(0, ary.length - 1);\r\n  }\r\n\r\n  function printAry(ary) {\r\n    outputForm.result.value = outputForm.result.value + ary.join(' ') + '\\n';\r\n  }\r\n}\r\n```\r\n\r\n### 실행 화면\r\n\r\n![실행 화면](./quickSort.png)\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- [모두의 알고리즘 with 자바스크립트](https://www.gilbut.co.kr/book/view?bookcode=BN002328)\r\n","excerpt":"퀵 정렬(Quick Sort)이란? 퀵 정렬 살펴보기 퀵 정렬 실행해보기 with 자바스크립트 퀵 정렬(Quick Sort)이란? 데이터의 범위를 반으로 나눈 다음, 그 범위를 다시 반으로 나누어 정렬하는 처리를 반복한다. 퀵 정렬 살펴보기 우선 피…","fields":{"slug":"/quick-sort.md/"},"frontmatter":{"date":"Jul 12, 2021","title":"퀵 정렬(Quick Sort)","tags":["JavaScript","Argorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n- 시간 복잡성이란?\r\n- O 표기법\r\n\r\n---\r\n\r\n## 시간 복잡성이란?\r\n\r\n계산의 복잡성,\r\n계산이 복잡해지는 만큼 처리하는 스텝의 개수가 늘어나므로 `실행 시간이 오래 걸린다`는 뜻이다.\r\n\r\n- 스텝 : CPU가 실행하는 명령\r\n\r\n---\r\n\r\n## O 표기법\r\n\r\n알고리즘의 `계산량이 얼마나` 될지 대략적으로 표현한 지표.  \r\n구체적인 실행 시간이나 명령의 개수는 알려주지 않는다.\r\n\r\n같은 프로그램을 실행해도 `컴퓨터의 처리 성능`에 따라 `실행 시간이 달라`지기 때문에,\r\n입력된 데이터 n의 크기에 따라 시간 계산량이 `어느 정도의 비율로 늘어나는지`를 O(n 식)의 형태로 표현하는 것이다.\r\n\r\nO(n) : 입력한 데이터의 크기(개수나 자릿수 등)을 n이라고 했을 때 알고리즘을 최대 n번 실행하면 처리가 완료된다는 뜻이다.(반드시 n번만에 완료된다는 것이 아니라 알고리즘의 최대 실행 횟수가 n번이라는 뜻이다.)\r\n\r\n### 1. O 표기법의 식\r\n\r\n차수가 가장 큰 항만 남기고 계수는 1로 한다.\r\n\r\n```\r\nO(3) → O(1)\r\nO(n-1) → O(n)\r\nO(4n²+3n) → O(n²)\r\nO(n³+7n²+12) → O(n³)\r\nO(2n³+3m²) → O(n³+m²)\r\n```\r\n\r\n### 2. 괄호 안에 자주 사용되는 식과 계산량의 대소 관계\r\n\r\n![O 표기법](./priority.png)\r\n\r\n### 3. 오더 수와 시간 계산량\r\n\r\n시간 계산량의 오더에서  \r\nO(n), O(n²), O(n³)과 같은 오더를 가르켜 `다항 시간 알고리즘`이라 부르며  \r\nO(n!), O(2ⁿ)과 같은 오더는 `지수 시간 알고리즘`이라 부른다.\r\n\r\n다항 시간 알고리즘으로는 어느 정도 실용적인 프로그램을 만들어 낼 수 있다.  \r\n하지만 지수 시간 알고리즘은 n값이 증가함에 따라 계산량도 급격히 늘어나기 때문에 현실적인 시간 내에 문제를 해결하지 못할 우려가 있다.\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- [모두의 알고리즘 with 자바스크립트](https://www.gilbut.co.kr/book/view?bookcode=BN002328)\r\n","excerpt":"시간 복잡성이란? O 표기법 시간 복잡성이란? 계산의 복잡성,\n계산이 복잡해지는 만큼 처리하는 스텝의 개수가 늘어나므로 는 뜻이다. 스텝 : CPU가 실행하는 명령 O 표기법 알고리즘의  될지 대략적으로 표현한 지표. 구체적인 실행 시간이나 명령의 …","fields":{"slug":"/time-complexity/"},"frontmatter":{"date":"Jul 12, 2021","title":"시간 복잡성과 O 표기법","tags":["Argorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n- 선택 정렬(Selection Sort)이란?\r\n- 선택 정렬 살펴보기\r\n- 선택 정렬 실행해보기 with 자바스크립트\r\n\r\n---\r\n\r\n## 선택 정렬(Selection Sort)이란?\r\n\r\n값이 가장 작은 숫자를 찾아 가장 왼쪽에 있는 데이터부터 순서대로 데이터를 교환하여 정렬하는 처리를 반복한다.\r\n\r\n## 선택 정렬 살펴보기\r\n\r\n- 우선 정렬하고자 하는 데이터 안에서 값을 하나 골라 임시 최솟값으로 정한다.\r\n- 데이터 전부를 임시 최솟값과 비교한다.\r\n- 임시 최솟값보다 값이 작은 데이터가 있다면, 값이 가장 작은 데이터의 위치와 임시 최솟값의 위치를 바꾼다.\r\n\r\n![실행 화면](./selectionSortEx.png)\r\n\r\n### 계산량 확인해보기\r\n\r\n데이터의 총 개수를 n이라고 하면 선택 정렬의 비교 횟수는\r\n처음에 n-1 번, 그 다음은 n-2, n-3 번 ... 이다.\r\n\r\n반복 횟수는 (n-1) + (n-2) + (n-3) + ... + 1 이므로 (n²-n)/2이다.  \r\n즉 선택 정렬의 오더는 O(n²)이 된다.\r\n\r\n오더가 버블 정렬과 같지만,  \r\n버블 정렬은 데이터의 위치를 바꾸는 횟수가 선택 정렬보다 많기 때문에 선택 정렬이 더 빨리 끝난다. 메모리에 저장된 데이터를 비교하는 처리보다 위치를 바꾸는 처리가 시간이 많이 걸리기 때문이다.\r\n\r\n## 선택 정렬 실행해보기 with 자바스크립트\r\n\r\n```html\r\n<!-- html -->\r\n<form name=\"inputForm\">\r\n  <div>선택 정렬</div>\r\n  <div>\r\n    <input name=\"str\" size=\"50\" type=\"text\" />\r\n    <input type=\"button\" value=\"정렬하기\" onClick=\"doSort()\" />\r\n  </div>\r\n</form>\r\n<form name=\"outputForm\">\r\n  <div>정렬 결과</div>\r\n  <div><textarea name=\"result\" cols=\"50\" rows=\"20\"></textarea></div>\r\n</form>\r\n```\r\n\r\n```javascript\r\n// javascript\r\nfunction doSort() {\r\n  let inputForm = document.forms.inputForm;\r\n  let outputFrom = document.forms.outputForm;\r\n  let ary = inputForm.str.value.split(',');\r\n  ary = ary.map(function (e) {\r\n    return Number(e);\r\n  });\r\n  outputForm.result.value = ary.join(' ') + '\\n';\r\n  outputForm.result.value = outputForm.result.value + '---' + '\\n';\r\n  selectionSort(ary);\r\n  outputForm.result.value = outputForm.result.value + '---' + '\\n';\r\n  printAry(ary);\r\n  outputForm.result.value = outputForm.result.value + 'done!' + '\\n';\r\n\r\n  function selectionSort(ary) {\r\n    let i = 0;\r\n    let min;\r\n    while (i < ary.length) {\r\n      min = i;\r\n      let j = i + 1;\r\n      while (j < ary.length) {\r\n        if (ary[min] > ary[j]) {\r\n          min = j;\r\n        }\r\n        j = j + 1;\r\n        printAry(ary);\r\n      }\r\n      let n = ary[i];\r\n      ary[i] = ary[min];\r\n      ary[min] = n;\r\n      i = i + 1;\r\n    }\r\n  }\r\n\r\n  function printAry(ary) {\r\n    outputForm.result.value = outputForm.result.value + ary.join(' ') + '\\n';\r\n  }\r\n}\r\n```\r\n\r\n### 실행 화면\r\n\r\n![실행 화면](./selectionSort.png)\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- [모두의 알고리즘 with 자바스크립트](https://www.gilbut.co.kr/book/view?bookcode=BN002328)\r\n","excerpt":"선택 정렬(Selection Sort)이란? 선택 정렬 살펴보기 선택 정렬 실행해보기 with 자바스크립트 선택 정렬(Selection Sort)이란? 값이 가장 작은 숫자를 찾아 가장 왼쪽에 있는 데이터부터 순서대로 데이터를 교환하여 정렬하는 처리…","fields":{"slug":"/selection-sort.md/"},"frontmatter":{"date":"Jul 12, 2021","title":"선택 정렬(Selection Sort)","tags":["Argorithm","JavaScript"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n### 1. mongoose 설치\r\n\r\n```bash\r\n$ npm install mongoose\r\n```\r\n\r\n### 2. MongoDB 연결 파일 생성\r\n\r\n현재 폴더 구조입니다.\r\n\r\n![현재 폴더 구조](./mongoose.png)\r\n\r\n```javascript\r\n// server/config/mongoose.js\r\nconst mongoose = require('mongoose');\r\nmodule.exports = () => {\r\n  function connect() {\r\n    mongoose.connect('localhost:27017', function (err) {\r\n      if (err) {\r\n        console.error('mongodb connection error', err);\r\n      }\r\n      console.log('mongodb connected');\r\n    });\r\n  }\r\n  connect();\r\n  mongoose.connection.on('disconnected', connect);\r\n};\r\n```\r\n\r\n로컬 몽고디비 주소인 localhost:27017을 사용했다.\r\n만약 몽고 디비 아이디와 비밀번혹 있다면,\r\n아이디:비밀번호@localhost:27017을 사용하면 된다.\r\n\r\n```javascript\r\nmongoose.connect('아이디:비밀번호@주소:포트/admin', { dbName: '데이터베이스' }, function (err) {});\r\n```\r\n\r\n### 3. 서버 실행시 자동으로 MongoDB 연결하기\r\n\r\n```javascript\r\n// server/main.js\r\nconst express = require('express');\r\nconst path = require('path');\r\nconst morgan = require('morgan');\r\nconst mongoose = require('./confing/mongoose.js'); //(*)\r\nconst session = require('express-session');\r\nimport api from './routes';\r\n\r\nconst webpack = require('webpack');\r\nconst WebpackDevServer = require('webpack-dev-server');\r\n\r\nlet app = express();\r\n\r\nconst port = 3000;\r\nconst devPort = 9000;\r\n\r\n// mongodb 연결\r\nmongoose();\r\n\r\n....\r\n```\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- https://www.zerocho.com/category/NodeJS/post/57924d1e8241b6f43951af1a\r\n","excerpt":"1. mongoose 설치 2. MongoDB 연결 파일 생성 현재 폴더 구조입니다.  로컬 몽고디비 주소인 localhost:27017을 사용했다.\n만약 몽고 디비 아이디와 비밀번혹 있다면,\n아이디:비밀번호@localhost:27017을 사용하면 …","fields":{"slug":"/mongodb-connect.md/"},"frontmatter":{"date":"Aug 15, 2020","title":"mongoose로 MongoDB 연결하기","tags":["Node.js","MongoDB"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\nnpm에서 dependency를 최신 버전으로 업데이트 하려면 하나씩 따로 업데이트해줘야 하는데.\n그냥 한번에 업데이트 하는 방법은 없을까?\n\n## npm-check-updates 를 이용한 업데이트\n\n### 1. npm-check-updates 전역 설치\n\n```bash\n$ npm install -g npm-check-updates\n\n```\n\n### 2. npm-check-updates 실행하기\n\n```bash\n$ ncu -u\n\n// 완료 되었으면 아래 명령어를 실행한다.\n\n$ npm install\n```\n\n### 3. 그러나 주의하자\n\n모든 의존성을 한번에 업데이트 하는 것은 프로젝트 관점에서 굉장히 큰 리스크를 가지고 있는 작업이다.\n하지만 여러가지 보일러플레이트를 github에서 관리해야할 때에는 분명 일괄 업데이트 기능도 필요하기 마련이다.\n강제로 최신버전으로 업데이트된 의존성들 사이의 호환성은 보장되지 않기 때문에 주의해서 사용하자\n\n---\n\n#### Reference\n\nhttps://ahribori.com/article/5a7996097eaff3172844ddb9\n","excerpt":"npm에서 dependency를 최신 버전으로 업데이트 하려면 하나씩 따로 업데이트해줘야 하는데.\n그냥 한번에 업데이트 하는 방법은 없을까? npm-check-updates 를 이용한 업데이트 1. npm-check-updates 전역 설치 2. n…","fields":{"slug":"/npm-check-updates/"},"frontmatter":{"date":"Aug 13, 2020","title":"pakage.json 종속성을 최신 버전으로 업데이트하기","tags":["npm","Node.js"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n- bundler란?\r\n- Webpack이란?\r\n- Babel과 Webpack 함께 사용하기\r\n\r\n---\r\n\r\n## bundler란?\r\n\r\n웹 사이트를 만들다보면 js, css, img 등 수 많은 파일들이 생겨난다. 웹 사이트 로딩 시 많은 파일들이 다운되어지고, 서버와의 접속이 많아져 애플리케이션의 로딩이 느려진다.\r\n\r\n각각의 서로 다른 패키지들이 서로 같은 이름을 가진 변수, 함수를 사용할 수 있다.\r\n이는 예상치 못한 충돌을 발생시킨다.\r\n\r\n이를 해결하기 위해 등장한 도구들을 `bundler`라 한다.\r\n\r\nbundle? '묶는다' 라는 뜻이다.\r\n\r\n### 대표적인 bundler\r\n\r\n- webpack\r\n- broserify\r\n- parcel\r\n\r\n---\r\n\r\n## Webpack이란?\r\n\r\n의존 관계에 있는 모듈들을 하나의 자바스크립트로 번들링하는 모듈 번들러\r\n\r\n- 이를 사용하면 의존 모듈이 하나의 파일로 번들링되므로 별도의 모듈 로더가 필요 없다.\r\n- 다수의 자바스크립트 파일을 하나의 파일로 번들링하므로 html 파일에서 script 태그로 다수의 자바스크립트 파일을 로드해야 하는 번거로움도 사라진다.\r\n\r\n### Webpack 설치\r\n\r\n```bash\r\n# Webpack V4는 webpack-cli를 요구한다\r\n$ npm install --save-dev webpack webpack-cli\r\n```\r\n\r\n---\r\n\r\n## Babel과 Webpack 함께 사용하기\r\n\r\n```bash\r\n# babel-loader 설치\r\n$ npm install --save-dev babel-loader\r\n```\r\n\r\n### webpack.config.js 파일 작성하기\r\n\r\n`webpack.config.js`은 Webpack이 실행될 때 참조하는 설정 파일이다.  \r\n프로젝트 루트에 `webpack.config.js` 파일을 생성하고 아래와 같이 작성한다.\r\n\r\n```javascript\r\n// Webpack이 실행될 때 참조하는 설정 파일\r\nconst path = require('path');\r\n\r\nmodule.exports = {\r\n  // entry file\r\n  entry: './src/js/main.js',\r\n\r\n  // 컴파일 + 번들링된 js 파일이 저장될 경로와 이름 지정\r\n  output: {\r\n    path: path.resolve(__dirname, 'dist/js'),\r\n    filename: 'bundle.js',\r\n  },\r\n\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.js$/,\r\n        include: [path.resolve(__dirname, 'src/js')],\r\n        exclude: /node_modules/,\r\n        use: {\r\n          loader: 'babel-loader',\r\n          options: {\r\n            presets: ['@babel/preset-env'],\r\n          },\r\n        },\r\n      },\r\n    ],\r\n  },\r\n};\r\n```\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- https://poiemaweb.com/es6-babel-webpack-2\r\n","excerpt":"bundler란? Webpack이란? Babel과 Webpack 함께 사용하기 bundler란? 웹 사이트를 만들다보면 js, css, img 등 수 많은 파일들이 생겨난다. 웹 사이트 로딩 시 많은 파일들이 다운되어지고, 서버와의 접속이 많아져 애…","fields":{"slug":"/webpack/"},"frontmatter":{"date":"Aug 11, 2020","title":"Webpack","tags":["JavaScript","ES6"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n- Babel이란?\r\n- Babel 사용해보기\r\n\r\n---\r\n\r\n## Babel이란?\r\n\r\n**Babel은 JavaScript 컴파일러이다.**\r\n즉, 최신 사양의 자바스크립트 코드를 IE나 구형 브라우저에서도 동작하는 ES5 이하의 코드로 변환하는 트랜스파일러라고 보면 된다.\r\n\r\n```javascript\r\n// ES6 화살표 함수와 ES7 지수 연산자\r\n[1, 2, 3].map((n) => n ** n);\r\n```\r\n\r\nBabel은 위와 같은 코드를 아래와 같이 변환한다.\r\n\r\n```javascript\r\n// ES5\r\n('use strict');\r\n\r\n[1, 2, 3].map(function (n) {\r\n  return Math.pow(n, n);\r\n});\r\n```\r\n\r\n---\r\n\r\n## Babel 사용해보기\r\n\r\n### 1. 사용하기 전 준비\r\n\r\n```bash\r\n$ npm install --save-dev @babel/core @babel/cli @babel/preset-env\r\n```\r\n\r\n설치가 완료되었으면 프로젝트 루트에 `.babelrc` 파일을 생성하고 아래와 같이 작성한다.\r\n\r\n```json\r\n// 지금 설치한 @babel/preset-env를 사용하겠다는 의미이다.\r\n{\r\n  \"presets\": [\"@babel/preset-env\"]\r\n}\r\n```\r\n\r\n### 2. @babel/preset-env는 뭐지?\r\n\r\n`@babel/preset-env`는 필요한 플러그인들을 프로젝트 지원 환경에 맞춰서 동적으로 결정해준다.  \r\n즉, 함께 사용되어야하는 Babel 플러그인을 모아 둔 것이다.  \r\n이를 **Babel 프리셋**이라고 부르며, Babel이 제공하는 공식 Babel 프리셋은 아래와 같다.\r\n\r\n- @babel/preset-env\r\n- @babel/preset-flow\r\n- @babel/preset-react\r\n- @babel/preset-typescript\r\n\r\n### 3. npm script를 사용해 트랜스파일링 하기\r\n\r\n```json\r\n// package.json 파일에 build를 추가한다.\r\n{\r\n  \"name\": \"es6-project\",\r\n  \"version\": \"1.0.0\",\r\n  \"scripts\": {\r\n    \"build\": \"babel src/js -w -d dist/js\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@babel/cli\": \"^7.7.0\",\r\n    \"@babel/core\": \"^7.7.2\",\r\n    \"@babel/preset-env\": \"^7.7.1\"\r\n  }\r\n}\r\n```\r\n\r\n- `-w` : 타킷 폴더에 있는 모든 파일들의 변경을 감지해 자동으로 트랜스파일한다.(`--watch` 옵션의 축약형)\r\n- `-d` : 트랜스파일링 된 결과물이 저장될 폴더를 지정한다(`--out-dir` 옵션의 축약형)\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- https://poiemaweb.com/es6-babel-webpack-1\r\n","excerpt":"Babel이란? Babel 사용해보기 Babel이란? Babel은 JavaScript 컴파일러이다.\n즉, 최신 사양의 자바스크립트 코드를 IE나 구형 브라우저에서도 동작하는 ES5 이하의 코드로 변환하는 트랜스파일러라고 보면 된다. Babel은 위와…","fields":{"slug":"/babel/"},"frontmatter":{"date":"Aug 10, 2020","title":"Babel","tags":["JavaScript","ES6"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n### 상속(Inheritance)\r\n\r\n<img src=\"./inheritance1.png\" title=\"inheritance\" alt=\"inheritance\" />\r\n\r\n- 자식 클래스는 어머니클래스를 extends 함으로써 메소드를 상속 받을 수 있다\r\n\r\n<img src=\"./inheritance2.png\" title=\"inheritance\" alt=\"inheritance\" />\r\n\r\n- interface :　메소드만 선언\r\n- implements : 메소드를 정의해야만 함\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- https://opentutorials.org/course/4408\r\n","excerpt":"상속(Inheritance) 자식 클래스는 어머니클래스를 extends 함으로써 메소드를 상속 받을 수 있다 interface :　메소드만 선언 implements : 메소드를 정의해야만 함 Reference https://opentutorials.…","fields":{"slug":"/java-inheritance.md/"},"frontmatter":{"date":"Feb 05, 2020","title":"Java의 상속(Inheritance)","tags":["Java"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n## Object.assign() 사용하기\r\n\r\n열거할 수 있는 하나 이상의 복사하고자 하는 객체로부터 대상 객체로 속성을 복사할 때 사용한다. 대상 객체를 반환한다.\r\n\r\n```javascript\r\nObject.assign(dest, [src1, src2, src3...])\r\n```\r\n\r\n- dest : 대상 객체(목표로 하는 객체)\r\n- src1, ...., srcN : 복사하고자 하는 객체\r\n\r\n```javascript\r\nlet user = { name: 'John' };\r\n\r\nlet permissions1 = { canView: true };\r\nlet permissions2 = { canEdit: true };\r\n\r\n// permissions1과 permissions2의 프로퍼티를 user로 복사한다.\r\nObject.assign(user, permissions1, permissions2);\r\n\r\n// now user = { name: \"John\", canView: true, canEdit: true }\r\n```\r\n\r\n목표 객체(user)에 동일한 이름을 가진 프로퍼티가 있는 경우\r\n\r\n```javascript\r\nlet user = { name: 'John' };\r\n\r\nObject.assign(user, { name: 'Pete' });\r\n\r\nalert(user.name); // user = { name: \"Pete\" }\r\n```\r\n\r\n빈 배열에 복사하기\r\n\r\n```javascript\r\nlet user = {\r\n  name: 'John',\r\n  age: 30,\r\n};\r\n\r\nlet clone = Object.assign({}, user);\r\n```\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- https://ko.javascript.info/object-copy\r\n- https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\r\n","excerpt":"Object.assign() 사용하기 열거할 수 있는 하나 이상의 복사하고자 하는 객체로부터 대상 객체로 속성을 복사할 때 사용한다. 대상 객체를 반환한다. dest : 대상 객체(목표로 하는 객체) src1, ...., srcN : 복사하고자 하는…","fields":{"slug":"/js-object-assign/"},"frontmatter":{"date":"Oct 18, 2019","title":"Object.assign을 이용한 객체 복사하기","tags":["JavaScript","ES6"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n- 'in' 연산자 사용하기\n- 'in' 연산자 응용하기 : 'for...in' 반복문\n\n---\n\n## 'in' 연산자 사용하기\n\n```javascript\n'key' in object;\n```\n\n※ in 왼쪽엔 반드시 프로퍼티 이름이 와야한다.\n\n```javascript\nlet user = { name: 'John', age: 30 };\n\nalert('age' in user); // user.age가 존재하므로 true 출력\nalert('blabla' in user); // user.blabla 존재하지 않으므로 false 출력\n\nlet obj = {\n  test: undefined,\n};\n\nalert(obj.test); // 값이 `undefined`이므로, 얼럿 창엔 undefined가 출력\n\nalert('test' in obj); // `in`을 사용하면 프로퍼티 유무를 제대로 확인할 수 있다.(true가 출력됨).\n```\n\n---\n\n## 'in' 연산자 응용하기 : 'for...in' 반복문\n\n```javascript\nfor (key in object) {\n  // 각 프로퍼티 키(key)를 이용하여 본문(body)을 실행한다.\n}\n```\n\n```javascript\nlet user = {\n  name: 'John',\n  age: 30,\n  isAdmin: true,\n};\n\nfor (let key in user) {\n  // 키\n  alert(key); // name, age, isAdmin\n  // 키에 해당하는 값\n  alert(user[key]); // John, 30, true\n}\n```\n\n---\n\n#### Reference\n\n- https://ko.javascript.info/object\n","excerpt":"'in' 연산자 사용하기 'in' 연산자 응용하기 : 'for...in' 반복문 'in' 연산자 사용하기 ※ in 왼쪽엔 반드시 프로퍼티 이름이 와야한다. 'in' 연산자 응용하기 : 'for...in' 반복문 Reference https://ko.…","fields":{"slug":"/js-object-in/"},"frontmatter":{"date":"Oct 16, 2019","title":"in 연산자로 객채의 프로퍼티 존재 여부 확인하기","tags":["JavaScript","ES6"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n- npm install --save-prod? npm install --save-dev?\r\n- npm install 와 npm install -g의 차이\r\n\r\n---\r\n\r\n## npm install --save-prod? npm install --save-dev?\r\n\r\n### 1. -P, --save-prod 플래그 사용\r\n\r\n- 패키지를 설치하고 프로젝트의 `dependencies` 목록에 추가한다.\r\n- 하지만 npm5부터는 이 플래그를 사용하지 않아도 dependecies에 항목을 추가할 수 있다.\r\n\r\n### 2. -D, —save-dev 플래그 사용\r\n\r\n- 패키지를 설치하고 프로젝트의 `devDependencies` 목록에 추가한다.\r\n\r\n### 3. dependencies 와 devDependencies\r\n\r\n- `dependencies` : express 패키지 처럼 실제 코드도 포함되며 앱 구동을 위해 필요한 의존성 파일들\r\n- `devDependencies` : concurrently 패키지처럼 실제 코드에 포함되지 않으며 개발 단계에만 필요한 의존성 파일들\r\n\r\n### 4. 굳이 사용하는 이유가 뭘까?\r\n\r\n플래그를 사용해 dependencies 와 devDependencies 로 의존성 목록을 구분하면 “이건 개발용, 이건 실제 서비스용” 으로 구분하기 쉬워진다는 면에서 개발자들에게 필요한 기능이라고 볼 수 있다.\r\n\r\n---\r\n\r\n## npm install 와 npm install -g 의 차이\r\n\r\n- `npm install (패키지명)` : 프로젝트 폴더에 패키지 설치\r\n- `npm install -g (패키지명)` : 시스템 폴더에 패키지 설치\r\n  (win10 기준으로는 `(사용자명)\\AppData\\Roaming\\npm\\node_modules` )\r\n  시스템의 node_modules 폴더 경로는 `npm root -g` 를 통해 찾을 수 있다.\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- https://ko.javascript.info/\r\n","excerpt":"npm install --save-prod? npm install --save-dev? npm install 와 npm install -g의 차이 npm install --save-prod? npm install --save-dev? 1. -P, -…","fields":{"slug":"/npm/"},"frontmatter":{"date":"Jun 05, 2019","title":"npm","tags":["Node.js","npm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n## PropTypes\r\n\r\n컴포넌트에 전달된 props를 검사합니다.\r\n\r\n### 1. prop-types 라이브러리 설치\r\n\r\n`React.PropTypes`는 원래 React 패키지에 내장 되어 있었습니다.  \r\n현재는 다른 패키지로 이동하여 따로 `prop-types` 라이브러리를 설치 해줘야 합니다.\r\n\r\n```bash\r\n$ npm install prop-types\r\n```\r\n\r\n`pakage.json` 파일로 들어가 다운되었는지 확인합니다.  \r\ndependencies 에 `prop-types`가 있다면 설치가 완료된 것입니다.\r\n\r\n```json\r\n.....\r\n\"dependencies\": {\r\n    \"@testing-library/jest-dom\": \"^4.2.4\",\r\n    \"@testing-library/react\": \"^9.5.0\",\r\n    \"@testing-library/user-event\": \"^7.2.1\",\r\n    \"axios\": \"^0.19.2\",\r\n    \"gh-pages\": \"^2.2.0\",\r\n    \"prop-types\": \"^15.7.2\", //(*)\r\n    \"react\": \"^16.13.1\",\r\n    \"react-dom\": \"^16.13.1\",\r\n    \"react-scripts\": \"3.4.1\"\r\n  },\r\n.....\r\n```\r\n\r\n### 2. import 하기\r\n\r\n```javascript\r\nimport PropTypes from 'prop-types';\r\n```\r\n\r\n### 3. 사용하기\r\n\r\n```javascript\r\nimport React from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\nclass Test extends React.Component {\r\n  render() {\r\n    return (\r\n      <div>\r\n        <h1>Hello, {this.props.name}</h1>\r\n        <p>age : {this.props.age}</p>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nTest.propTypes = {\r\n  name: PropTypes.string.isRequired, //name은 문자이고, 부모 컴포넌트로부터 반드시 값을 받아야한다.\r\n  age: PropTypes.number, //age는 숫자\r\n};\r\n\r\nexport default Test;\r\n```\r\n\r\n만약 `name props`에 숫자가 전달되거나 아무런 값도 전달 받지 못했다면, 경고문이 JavaScript 콘솔을 통해 보일 것입니다.\r\n\r\n<img src=\"./error.png\" align=\"left\" width=\"450px\" height=\"250px\"  title=\"error\" alt=\"error\"/>\r\n\r\n### 4. PropTypes 공식 문서\r\n\r\n**[PropTypes 공식 문서](https://ko.reactjs.org/docs/typechecking-with-proptypes.html)**에 따라 다양한 Type을 검사하는 방법을 보면 아래와 같습니다.\r\n\r\n```javascript\r\nimport PropTypes from 'prop-types';\r\n\r\nMyComponent.propTypes = {\r\n  // prop가 특정 JS 형식임을 선언할 수 있습니다.\r\n  // 이것들은 기본적으로 모두 선택 사항입니다.\r\n  optionalArray: PropTypes.array,\r\n  optionalBool: PropTypes.bool,\r\n  optionalFunc: PropTypes.func,\r\n  optionalNumber: PropTypes.number,\r\n  optionalObject: PropTypes.object,\r\n  optionalString: PropTypes.string,\r\n  optionalSymbol: PropTypes.symbol,\r\n\r\n  // 랜더링 될 수 있는 것들은 다음과 같습니다.\r\n  // 숫자(numbers), 문자(strings), 엘리먼트(elements), 또는 이러한 타입들(types)을\r\n  // 포함하고 있는 배열(array) (혹은 배열의 fragment)\r\n  optionalNode: PropTypes.node,\r\n\r\n  // React 엘리먼트.\r\n  optionalElement: PropTypes.element,\r\n\r\n  // React 엘리먼트 타입 (ie. MyComponent)\r\n  optionalElementType: PropTypes.elementType,\r\n\r\n  // prop가 클래스의 인스턴스임을 선언할 수 있습니다.\r\n  // 이 경우 JS's instanceof 연산자를 사용합니다.\r\n  optionalMessage: PropTypes.instanceOf(Message),\r\n\r\n  // 열거형(enum)으로 처리하여 prop가 특정 값들로 제한되도록 할 수 있습니다.\r\n  optionalEnum: PropTypes.oneOf(['News', 'Photos']),\r\n\r\n  // 여러 종류중 하나의 종류가 될 수 있는 객체\r\n  optionalUnion: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.instanceOf(Message)]),\r\n\r\n  // 특정 타입의 행렬\r\n  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),\r\n\r\n  // 특정 타입의 프로퍼티 값들을 갖는 객체\r\n  optionalObjectOf: PropTypes.objectOf(PropTypes.number),\r\n\r\n  // 특정 형태를 갖는 객체\r\n  optionalObjectWithShape: PropTypes.shape({\r\n    color: PropTypes.string,\r\n    fontSize: PropTypes.number,\r\n  }),\r\n\r\n  // An object with warnings on extra properties\r\n  optionalObjectWithStrictShape: PropTypes.exact({\r\n    name: PropTypes.string,\r\n    quantity: PropTypes.number,\r\n  }),\r\n\r\n  // 위에 있는 것 모두 `isRequired`와 연결하여 prop가 제공되지 않았을 때\r\n  // 경고가 보이도록 할 수 있습니다.\r\n  requiredFunc: PropTypes.func.isRequired,\r\n\r\n  // 모든 데이터 타입이 가능한 값\r\n  requiredAny: PropTypes.any.isRequired,\r\n\r\n  // 사용자 정의 유효성 검사기를 지정할 수도 있습니다.\r\n  // 검사 실패 시에는 에러(Error) 객체를 반환해야 합니다.\r\n  // `oneOfType`안에서는 작동하지 않으므로 `console.warn` 혹은 throw 하지 마세요.\r\n  customProp: function (props, propName, componentName) {\r\n    if (!/matchme/.test(props[propName])) {\r\n      return new Error('Invalid prop `' + propName + '` supplied to' + ' `' + componentName + '`. Validation failed.');\r\n    }\r\n  },\r\n\r\n  // `arrayOf` 와 `objectOf 에 사용자 정의 유효성 검사기를 적용할 수 있습니다.\r\n  // 검사 실패 시에는 에러(Error) 객체를 반환해야 합니다.\r\n  // 유효성 검사기는 배열(array) 혹은 객체의 각 키(key)에 대하여 호출될 것입니다.\r\n  // 유효성 검사기의 첫 두 개의 변수는 배열 혹은 객체 자신과 현재 아이템의 키입니다.\r\n\r\n  customArrayProp: PropTypes.arrayOf(function (propValue, key, componentName, location, propFullName) {\r\n    if (!/matchme/.test(propValue[key])) {\r\n      return new Error(\r\n        'Invalid prop `' + propFullName + '` supplied to' + ' `' + componentName + '`. Validation failed.'\r\n      );\r\n    }\r\n  }),\r\n};\r\n```\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- https://velopert.com/1130\r\n- https://ko.reactjs.org/\r\n","excerpt":"PropTypes 컴포넌트에 전달된 props를 검사합니다. 1. prop-types 라이브러리 설치 는 원래 React 패키지에 내장 되어 있었습니다. 현재는 다른 패키지로 이동하여 따로  라이브러리를 설치 해줘야 합니다.  파일로 들어가 다운되었…","fields":{"slug":"/react-proptypes.md/"},"frontmatter":{"date":"Jun 03, 2019","title":"React PropTypes를 사용해 타입 검사하기","tags":["React"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n- async\r\n- await\r\n- async-await : 에러 핸들링하기\r\n- async/await 과 promise.then/catch 비슷한데 뭘 쓰지?\r\n\r\n---\r\n\r\n## async\r\n\r\n`async`는 function 앞에 위치한다.\r\n\r\n```javascript\r\nasync function f() {\r\n  return 1;\r\n}\r\n\r\nf().then(alert); // 1\r\n```\r\n\r\n- function 앞에 `async`를 붙이면 해당 함수는 항상 프라미스를 반환한다.\r\n\r\n---\r\n\r\n## await\r\n\r\n```javascript\r\n// await는 async 함수 안에서만 동작한다.\r\nasync function f() {\r\n  let promise = new Promise((resolve, reject) => {\r\n    setTimeout(() => resolve('완료!'), 1000);\r\n  });\r\n\r\n  let result = await promise; // 프라미스가 이행될 때까지 기다림\r\n\r\n  alert(result); // \"완료!\"\r\n}\r\n\r\nf();\r\n```\r\n\r\n- 프라미스가 처리될 때까지 함수 실행을 기다리게 한다.\r\n- 프라미스가 처리되면 그결과와 함께 실행이 재게 된다.\r\n- 프라미스가 처리되길 기다리는 동안에 엔진은 다른 일(다른 스크립트를 실행, 이벤트 처리 등)을 할 수 있다.\r\n\r\n---\r\n\r\n## async & await : 에러 핸들링하기\r\n\r\n```javascript\r\nasync function f() {\r\n  await Promise.reject(new Error('에러 발생!'));\r\n}\r\n\r\n// throw문을 사용해 위와 동일한 코드를 작성할 수 있다.\r\nasync function f() {\r\n  throw new Error('에러 발생!');\r\n}\r\n\r\n// 또는 try catch문을 사용해 잡을 수 있다.\r\nasync function f() {\r\n  try {\r\n    let response = await fetch('http://유효하지-않은-url');\r\n    let user = await response.json();\r\n  } catch (err) {\r\n    // fetch와 response.json에서 발행한 에러 모두를 여기서 잡습니다.\r\n    alert(err);\r\n  }\r\n}\r\n\r\nf();\r\n```\r\n\r\n---\r\n\r\n## async/await 과 promise.then/catch 비슷한데 뭘 쓰지?\r\n\r\n비슷하다. 둘 중 편한 것을 쓰면 된다.\r\n\r\n하지만 여러 개의 프라미스가 모두 처리되길 기다려야 하는 상황이라면...\r\n\r\n```javascript\r\n// 프라미스 처리 결과가 담긴 배열을 기다립니다.\r\nlet results = await Promise.all([\r\n  fetch(url1),\r\n  fetch(url2),\r\n  ...\r\n]);\r\n```\r\n\r\n실패한 프라미스에서 발생한 에러는 보통 에러와 마찬가지로 Promise.all로 전파된다. 에러 때문에 생긴 예외는 try...catch로 감싸 잡을 수 있다.\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- https://ko.javascript.info/\r\n","excerpt":"async await async-await : 에러 핸들링하기 async/await 과 promise.then/catch 비슷한데 뭘 쓰지? async 는 function 앞에 위치한다. function 앞에 를 붙이면 해당 함수는 항상 프라미스를 …","fields":{"slug":"/async-await/"},"frontmatter":{"date":"Jun 02, 2019","title":"async-await","tags":["JavaScript","ES6"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n- 컴포넌트 초기 생성(Mount)\r\n- 컴포넌트 업데이트\r\n- 컴포넌트 제거(마운트 해제)\r\n\r\n---\r\n\r\n## 컴포넌트 초기 생성(Mount)\r\n\r\n컴포넌트가 브라우저에 나타나기 전, 후에 호출되는 API  \r\n아래의 순서대로 호출 된다.\r\n\r\n- `constructor()`\r\n- `static getDerivedStateFromProps()`\r\n- `render()`\r\n- `componentDidMount()`\r\n\r\n### 1. constructor( )\r\n\r\n컴포넌트 생성자 함수, 컴포넌트가 새로 만들어질 때마다 이 함수가 호출된다.\r\n\r\n### 2. static getDerivedStateFromProps( )\r\n\r\n```javascript\r\nstatic getDerivedStateFromProps(prosp,state) {\r\n  // 여기서는 setState 를 하는 것이 아니라\r\n  // 특정 props 가 바뀔 때 설정하고 설정하고 싶은 state 값을 리턴하는  형태로 사용된다.\r\n  /*\r\n  if (props.value !== state.value) {\r\n    return { value: props.value };\r\n  }\r\n  return null; // null 을 리턴하면 따로 업데이트 할 것은 없다라는 의미\r\n  */\r\n}\r\n```\r\n\r\n최초 마운트 시와 업데이트 시 모두에서 render 메서드를 호출하기 직전에 호출된다.\r\n\r\n- 부모 컴포넌트가 다시 렌더링을 발생 시켰을 때에만 실행된다.\r\n- 해당 컴포넌트 내에서 지역적인 `setState()`가 발생한 경우에는 실행되지 않는다.\r\n\r\n### 3. componentDidMount( )\r\n\r\n컴포넌트가 마운트된 직후, 즉 컴포넌트가 화면에 나타나게 됐을 때 호출된다. 외부에서 데이터를 불러오기 위해, 네트워크 요청을 보내기 적절한 위치이다.\r\n\r\n- 외부 라이브러리 연동 : D3,\r\n- 컴포넌트에서 필요한 데이터 요청 : Ajax, GraphQL, etc\r\n- DOM에 관련된 작업 : 스크롤 설정, 크기 읽어오기 등\r\n\r\n---\r\n\r\n## 컴포넌트 업데이트\r\n\r\nprops 또는 state가 변경되어 컴포넌트가 다시 렌더링될 때, 아래의 순서대로 호출된다.\r\n\r\n- `static getDerivedStateFromProps()`\r\n- `shouldComponentUpdate()`\r\n- `render()`\r\n- `getSnapshotBeforeUpdate()`\r\n- `componentDidUpdate()`\r\n\r\n### 1. shouldComponentUpdate( )\r\n\r\n```javascript\r\nshouldComponentUpdate(nextProps, nextState) {\r\n  // return false 하면 render()를 발생시키지 않는다.\r\n  // return this.props.checked !== nextProps.checked\r\n  return true;\r\n}\r\n```\r\n\r\n이 메서드는 오직 성능 최적화만을 위한 것이다.\r\n\r\n- `this.props`와 `nextProps`, 그리고 `this.state`와 `nextState`를 비교해 사용한다.\r\n\r\n### 2. getSnapshotBeforeUpdate( )\r\n\r\n```javascript\r\ngetSnapshotBeforeUpdate(prevProps, prevState);\r\n```\r\n\r\n가장 마지막으로 렌더링된 결과가 DOM 등에 반영되었을 때에 호출된다. 이 생명주기 메서드가 반환하는 값은 `componentDidUpdate()`에 인자로 전달된다.\r\n\r\n### 3. componentDidUpdate( )\r\n\r\n```javascript\r\ncomponentDidUpdate(prevProps, prevState, snapshot);\r\n```\r\n\r\n이 메서드는 갱신이 일어난 직후에 호출된다.\r\n\r\n- 이전과 현재의 props를 비교해 네트워크 요청을 보내는 작업이 대부분 이 메서드에서 이루어진다.\r\n\r\n```javascript\r\ncomponentDidUpdate(prevProps) {\r\n  // 전형적인 사용 사례 (props 비교)\r\n  if (this.props.userID !== prevProps.userID) {\r\n    this.fetchData(this.props.userID);\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 컴포넌트 제거(마운트 해제)\r\n\r\n- `componentWillUnmount()`\r\n\r\n### 1. componentWillUnmount( )\r\n\r\n```javascript\r\ncomponentWillUnmount() {\r\n  // 이벤트, setTimeout, 외부 라이브러리 인스턴스 제거\r\n}\r\n```\r\n\r\n컴포넌트가 마운트 해제되어 제거되기 직전에 호출된다.\r\n\r\n- `componentDidMount()` 내에서 생성된 구독 해제\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- https://velopert.com/1130\r\n- https://ko.reactjs.org/\r\n","excerpt":"컴포넌트 초기 생성(Mount) 컴포넌트 업데이트 컴포넌트 제거(마운트 해제) 컴포넌트 초기 생성(Mount) 컴포넌트가 브라우저에 나타나기 전, 후에 호출되는 API 아래의 순서대로 호출 된다.     1. constructor( ) 컴포넌트 생성…","fields":{"slug":"/react-lifecycle/"},"frontmatter":{"date":"May 30, 2019","title":"React LifeCycle(리액트 생명주기)","tags":["React"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n- Promise 기본\n- 메서드 : then, catch, finally\n\n---\n\n## Promise 기본\n\n### 1. promise 객체 생성\n\n```javascript\nlet promise = new Promise(function (resolve, reject) {\n  // new Promise에 전달되는 함수 : executor(실행자, 실행함수)\n});\n```\n\n- `resolve(value)` — 일이 성공적으로 끝난 경우 그 결과를 나타내는 value와 함께 호출\n- `reject(error)` — 에러 발생 시 에러 객체를 나타내는 error와 함께 호출\n- executor는 resolve나 reject 중 하나를 반드시 호출해야 한다.\n\n### 2. 위의 pormise 객체의 내부 프로퍼티 살펴보기\n\n<img src=\"./promise_prop.png\" title=\"pormise 객체의 내부 프로퍼티\" alt=\"promise_property\"></img>  \n참조 : https://ko.javascript.info/\n\n- state : 처음엔 \"pending\" / resolve가 호출되면 _\"fulfilled\"_ / reject가 호출되면 _\"rejected\"_ 로 변한다.\n- result : 처음엔 undefined / resolve(value)가 호출되면 _value_ / reject(error)가 호출되면 _error_ 로 변한다.\n\n---\n\n## 메서드 : then, catch, finally\n\n### 1. then\n\n```javascript\npromise.then(\n  function (result) {\n    /* 프라미스가 이행되었을 때 실행, 실행결과를 받는다.*/\n  },\n  function (error) {\n    /* 프라미스가 거부되었을 때 실행, 에러를 받는다. */\n  }\n);\n```\n\nex1 ) 성공적으로 이행된 프라미스\n\n```javascript\nlet promise = new Promise(function (resolve, reject) {\n  setTimeout(() => resolve('done!'), 1000);\n});\n\n// resolve 함수는 .then의 첫 번째 함수(인수)를 실행.\npromise.then(\n  (result) => alert(result), // 1초 후 \"done!\"을 출력\n  (error) => alert(error) // 실행되지 않음\n);\n```\n\nex2 ) 에러가 발생한 프라미스\n\n```javascript\nlet promise = new Promise(function (resolve, reject) {\n  setTimeout(() => reject(new Error('에러 발생!')), 1000);\n});\n\n// reject 함수는 .then의 두 번째 함수를 실행.\npromise.then(\n  (result) => alert(result), // 실행되지 않음\n  (error) => alert(error) // 1초 후 \"Error: 에러 발생!\"를 출력\n);\n```\n\n### 2. catch\n\n- 에러가 발생한 경우만 다루고 싶다면 `.catch(errorHandlingFunction)`를 사용한다.\n- `.then(null, errorHandlingFunction)` 과 동일하게 작동한다..\n\n```javascript\nlet promise = new Promise((resolve, reject) => {\n  setTimeout(() => reject(new Error('에러 발생!')), 1000);\n});\n\npromise.catch(alert); // 1초 뒤 \"Error: 에러 발생!\" 출력\n```\n\n### 3. finally\n\n- `.finally(f)` 호출은 `.then(f, f)`과 유사하다.\n\n```javascript\nnew Promise((resolve, reject) => {\n  /* 시간이 걸리는 어떤 일을 수행하고, 그 후 resolve, reject를 호출함 */\n})\n  // 성공·실패 여부와 상관없이 프라미스가 처리되면 실행됨\n  .finally(() => 로딩 인디케이터 중지)\n  .then(result => result와 err 보여줌 => error 보여줌)\n```\n\n---\n\n#### Reference\n\n- https://ko.javascript.info/\n","excerpt":"Promise 기본 메서드 : then, catch, finally Promise 기본 1. promise 객체 생성  — 일이 성공적으로 끝난 경우 그 결과를 나타내는 value와 함께 호출  — 에러 발생 시 에러 객체를 나타내는 error와 함…","fields":{"slug":"/promise.md/"},"frontmatter":{"date":"May 26, 2019","title":"Promise","tags":["JavaScript"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n## constructor\r\n\r\n객체(인스턴스)를 생성하고 클래스 필드를 초기화하기 위한 특수한 메소드  \r\n※ 클래스 필드 : 자바스크립트의 생성자 함수에서 this에 추가한 프로퍼티\r\n\r\n### 1. 예문으로 이해하기\r\n\r\n```javascript\r\n// 클래스 선언문\r\nclass Person {\r\n  // constructor(생성자). 이름을 바꿀 수 없다.\r\n  constructor(name) {\r\n    // this는 클래스가 생성할 인스턴스를 가리킨다.\r\n    // _name은 클래스 필드이다.\r\n    this._name = name;\r\n  }\r\n}\r\n\r\n// 인스턴스 생성\r\nconst me = new Person('Lee');\r\nconsole.log(me); // Person {_name: \"Lee\"}\r\ncs;\r\n```\r\n\r\n- 클래스는 `constructor`라는 이름을 가진 특별한 메서드를 하나씩만 가질 수 있습니다. 2개 이상일 시 `SyntaxError`을 유발합니다.\r\n\r\n- 인스턴스를 생성할 때 new 연산자와 함께 호출한 것이 바로 `constructor`이며 `constructor`의 파라미터에 전달한 값은 클래스 필드에 할당합니다.\r\n\r\n```javascript\r\n// 클래스 선언문\r\nclass Person {}\r\n\r\nconst me = new Person();\r\nconsole.log(me); // Person {}\r\n\r\n// 프로퍼티 동적 할당 및 초기화\r\nme._name = 'daeun';\r\nconsole.log(me); // Person {_name: \"daeun\"}\r\n```\r\n\r\n- `constructor`은 생략할 수 있습니다. 생략하면 클래스에 `constructor( ){ }`를 포함한 것과 동일하게 동작합니다.\r\n\r\n- 따라서 인스턴스에 프로퍼티를 추가하려면 인스턴스를 생성한 이후 프로퍼티를 동적으로 추가해야 합니다.\r\n\r\n```javascript\r\nclass Person {\r\n  constructor(name) {\r\n    this._name = name;\r\n  }\r\n}\r\n\r\nconst me = new Person('daeun');\r\nconsole.log(me);\r\n```\r\n\r\n- `constructor`는 인스턴스의 생성과 동시에 클래스 필드의 생성과 초기화를 실행합니다.\r\n\r\n- 따라서 클래스 필드를 초기화해야 한다면 `constructor`를 생략해서는 안됩니다.\r\n\r\n---\r\n\r\n#### Reference\r\n\r\n- https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Classes/constructor\r\n\r\n- https://poiemaweb.com/es6-class\r\n","excerpt":"constructor 객체(인스턴스)를 생성하고 클래스 필드를 초기화하기 위한 특수한 메소드 ※ 클래스 필드 : 자바스크립트의 생성자 함수에서 this에 추가한 프로퍼티 1. 예문으로 이해하기 클래스는 라는 이름을 가진 특별한 메서드를 하나씩만 가질…","fields":{"slug":"/es6-constructor/"},"frontmatter":{"date":"Apr 24, 2019","title":"ES6 Class의 생성자(constructor) 함수","tags":["ES6","JavaScript"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n## GitHub Pages\r\n\r\nGitHub Pages는 GitHub Repository를 이용해 웹 사이트를 무료로 호스팅해주는 서비스입니다.\r\n\r\n- 사용자가 GitHub Repository에 자신의 웹 프로젝트 빌드 결과물을 업로드 하면 GitHub가 그 결과물을 호스팅해 줍니다.\r\n\r\n### 1. 로컬 저장소에 Commit 하기\r\n\r\n```bash\r\n$ git add .\r\n$ git commit -m \" Deploying to Github Pages\"\r\n```\r\n\r\n지금까지 프로젝트의 파일 및 폴더의 추가/변경 사항을 로컬 저장소에 기록합니다.\r\n\r\n### 2. GiHub에 Repository 생성 (원격 저장소 생성)\r\n\r\n<img src=\"./repository.png\" title=\"github_repository\" alt=\"github_repository\" />\r\n\r\n자신의 GitHub에 새로운 repository를 생성합니다\r\n\r\n### 3. 로컬 저장소와 원격 저장소 연결\r\n\r\n원격 저장소의 주소를 입력해 로컬 저장소와 원격 저장소를 연결해 줍니다.\r\n\r\n```bash\r\n$ git remote add origin https://github.com/daeun012/deploy_test.git\r\n```\r\n\r\n로컬 저장소에 기록 한 내용을 원격 저장소에 업로드 합니다.\r\n\r\n```bash\r\n$ git push -u origin master\r\n```\r\n\r\n### 4. gh-pages 패키지 설치\r\n\r\n```bash\r\n$ npm install gh-pages\r\n```\r\n\r\n### 5. package.json 수정\r\n\r\npackage.json 파일에 `\"homepage\": \"https://{GitHub username}.github.io/{Repository name}/\" `을 추가해 주고,\r\n\r\n```json\r\n....\r\n\"browserslist\": {\r\n\"production\": [\r\n\">0.2%\",\r\n\"not dead\",\r\n\"not op_mini all\"\r\n],\r\n\"development\": [\r\n\"last 1 chrome version\",\r\n\"last 1 firefox version\",\r\n\"last 1 safari version\"\r\n]\r\n\r\n},\r\n\"homepage\": \"https://daeun012.github.io/deploy_test/\" //(*)\r\n}\r\n```\r\n\r\n`package.json`의 `\"scripts\"` 부분에 `\"deploy\": \"gh-pages -d build\", \"predeploy\": \"npm run build\"`를 추가해 줍니다.\r\n\r\n```json\r\n...\r\n\"scripts\": {\r\n\"start\": \"react-scripts start\",\r\n\"build\": \"react-scripts build\",\r\n\"test\": \"react-scripts test\",\r\n\"eject\": \"react-scripts eject\",\r\n\"deploy\": \"gh-pages -d build\", //(*)\r\n\"predeploy\": \"npm run build\" //(*)\r\n},\r\n...\r\n```\r\n\r\n- `npm run build` : 현재 프로젝트 코드를 빌드합니다.\r\n\r\n- `gh-pages -d build` : build 디렉토리 (-d)에 있는 파일을 GitHub Pages에 업로드 합니다.\r\n\r\n### 마지막! GitHub Pages에 빌드 결과물 업로드\r\n\r\n```bash\r\n$ npm run deploy\r\n```\r\n\r\nhompage에 입력했던 주소로 접속하시면 프로젝트가 배포된 것을 볼 수 있을 겁니다.\r\n\r\n---\r\n\r\n#### Reference\r\n\r\nhttps://lktprogrammer.tistory.com/5\r\n","excerpt":"GitHub Pages GitHub Pages는 GitHub Repository를 이용해 웹 사이트를 무료로 호스팅해주는 서비스입니다. 사용자가 GitHub Repository에 자신의 웹 프로젝트 빌드 결과물을 업로드 하면 GitHub가 그 결과물…","fields":{"slug":"/github-deploy.md/"},"frontmatter":{"date":"Apr 24, 2019","title":"GitHub Pages로 React 배포(Deploy)하기","tags":["Github","React"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n- DNS란?\r\n- DNS의 작동 원리\r\n\r\n---\r\n\r\n## DNS(Domain Name System)란?\r\n\r\n우리는 인터넷을 이용할 때 웹 브라우저의 주소 창에 도메인 이름을 입력한다. 그러면 브라우저는 우리가 원하는 페이지를 띄어준다.\r\n\r\n하지만 실제 웹 브라우저와 웹 서버는 숫자로 구성된 IP 주소로 통신한다.\r\n\r\n그럼 IP가 아닌 도메인 이름을 입력했는데 어떻게 알아듣고 원하는 페이지를 띄어주는 걸까?\r\n\r\n바로 **사용자가 입력한 도메인 주소**를 **IP주소로 변환해주는 시스템인 DNS를 사용**하기 때문이다.\r\n\r\n---\r\n\r\n## DNS의 작동 원리\r\n\r\n![DNS작동원리](./dns.png)\r\n웹 브라우저는 입력된 도메인 주소의 서버와 통신 하기 위해 DNS 서버와 메시지를 교환해 해당 서버의 IP주소를 획득하고, 사용자의 요청에 따라 원하는 정보들을 받아온다.\r\n\r\n---\r\n\r\n#### Reference\r\n\r\nhttps://opentutorials.org/course/3276/20299\r\n","excerpt":"DNS란? DNS의 작동 원리 DNS(Domain Name System)란? 우리는 인터넷을 이용할 때 웹 브라우저의 주소 창에 도메인 이름을 입력한다. 그러면 브라우저는 우리가 원하는 페이지를 띄어준다. 하지만 실제 웹 브라우저와 웹 서버는 숫자로…","fields":{"slug":"/front-dns.md/"},"frontmatter":{"date":"Mar 06, 2019","title":"DNS와 작동원리","tags":["Front-End"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n## 호스팅(Hosting)\r\n\r\n호스팅의 의미를 알기전에 호스트의 의미를 알아보자,\r\n\r\n### 1. 호스트(Host)란?\r\n\r\n호스트란?**각각의 인터넷에 연결되어 있는 컴퓨터 혹은 장치**들을 가르켜 **호스트**라고 한다.\r\n\r\n### 2. 호스팅이란?\r\n\r\n정보를 제공하는 사업자, 즉 서버 쪽에서 사용되는 컴퓨터 또는 소프트웨어 이러한 것들을 제공하는 사업자를 말한다.  \r\n즉, **우리가 직접 웹서버를 운영하는 일은 쉽지 않기 때문에, 이러한 일을 대신해주는 사업**을 **호스팅**이라고 한다.\r\n\r\n### 3.대표적인 예시\r\n\r\n대표적으로 **웹 호스팅**, **서버 호스팅** 등이 있다.\r\n\r\n- 웹 호스팅 : 웹 애플리케이션을 위한 모든 것을 제공해준다. (웹서버, 미들웨어, 데이터베이스.. 등 모든 것 설치되어있다). 그러기에 웹 애플리케이션만 업로드 하면 된다.\r\n\r\n- 서버 호스팅 : 서버를 운영할 수 있는 컴퓨터만 제공한다. 자기가 원하는 것들을 설치할 수 있어 컴퓨터로 할 수 있는 모든 일을 할 수 있다. 자유도, 활용도가 높지만 직접 자기가 운영해야한다.\r\n\r\n---\r\n\r\n#### Reference\r\n\r\nhttps://opentutorials.org/course/1688/9485\r\n","excerpt":"호스팅(Hosting) 호스팅의 의미를 알기전에 호스트의 의미를 알아보자, 1. 호스트(Host)란? 호스트란?각각의 인터넷에 연결되어 있는 컴퓨터 혹은 장치들을 가르켜 호스트라고 한다. 2. 호스팅이란? 정보를 제공하는 사업자, 즉 서버 쪽에서 사…","fields":{"slug":"/front-hosting/"},"frontmatter":{"date":"Mar 05, 2019","title":"호스팅(Hosting)이란?","tags":["Front-End"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}